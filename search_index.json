[
["index.html", "Statistički softver 2 Predgovor", " Statistički softver 2 Blagoje Ivanović Poslednja izmena: 11 March, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 2. Cilj kursa je da se upoznamo sa često korišćenim alatima pri analizi podataka koristeći programski jezik R, kao i da primenimo stečena statistička znanja na podacima. Velikim delom ćemo pratiti kurs koji se nalazi na https://moderndive.com, uz odredjene izmene. Vrlo dobra literatura koju ćemo koristiti često na kursu jeste i knjiga R for Data Science, a za one koji bi da nauče nešto više o R-u, obavezna literatura je Advanced R. "],
["graficki-prikaz-podataka.html", "1 Grafički prikaz podataka 1.1 Uvodni primeri i napomene 1.2 Razni primeri grafika", " 1 Grafički prikaz podataka Prvo ćemo se zabavljati grafičkim prikazima podataka i crtanjem raznih grafika, koristeći paket ggplot2 koji je jedan od najupotrebljenijih paketa u R-u. Velika prednost ovog paketa je što sa vrlo malo koda možemo da pravimo dosta bogate grafike. S druge strane, ima malo čudniju sintaksu od klasičnih grafika u R-u, pa zahteva malo učenja. Medjutim ta sintaksa je prilično smislena i elegentna, kao što ćemo videti kroz rad. 1.1 Uvodni primeri i napomene Kao inicijalnu demonstraciju sile, pogledajmo sledeći grafik, na kome se vidi dosta različitih elemenata, poput raznih boja za razne promenljive, različite veličine tačaka, prikaz legende itd. Kod koji generiše ovaj grafik je sledeči. Primetite da samo zadnja naredba crta grafik, pre toga je prosto smanjivanje količine podataka. library(ggplot2) library(gapminder) gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) Proći ćemo kroz sve delove ovog koda vremenom i ubrzo ćete moći da pravite ovakve grafike bez problema. Prvo ipak malo teorije. Paket ggplot2 se zasniva na takozvanoj “gramatici grafike” i uočljivo je u prethodnom kodu da se grafici prave “sabiranjem”. Zabpravo dodajemo komponentu po komponentu na grafik. Glavni delovi koje grafik ima su: Podaci (data): Skup podataka koji se prikazuje Geometrijski objekat (geom_*): Tip geometrijskog objekta kojim se prikazuju podaci. Mogu biti tačke, linije, histogrami, itd. Estetski parametri (aes()): Estetski atributi koji se mogu dodeliti geometrijskim objektima. Uvek imamo x/y koordinatu, a možemo dodati i boju, veličinu, itd. Svaki estetski parametar se može primeniti na promenljivu u podacima, pa svaki element u podacima ima svoju vrednost tog parametra (npr. gore su sve tačke iz istih kontinenata isto obojene). Grafike koristeći ggplot pravimo prateći sledeći šablon: ggplot(data = &lt;Podaci&gt;) + &lt;geom_funkcija&gt;(mapping = aes(&lt;estetski parametri&gt;)) Bitno je pomenuti da ne postoji podrazumevani grafik u ggplot, već se mora dodati neki geometrijcki objekat (pozivom neke geom_* funkcije). Pozivanjem samo ggplot(data=...) dobija se prazan grafik: ggplot(data = gapminder2007) Neki estetski parametri se mogu dodeliti i na početku, npr. odmah možemo postaviti x i y osu u pozivu ggplot, pa će ona ostati fiksna za sledeće elemente grafika. Ovako možemo nacrtati prethodni grafik (bez boja i sl.). # sablon bi bio: # ggplot(data=gapminder2007) + # geom_point(aes(x = gdpPercap, y = lifeExp)) ggplot(data = gapminder2007, aes(x = gdpPercap, y = lifeExp)) + geom_point() Vrlo bitna napomena! Znak &quot; + &quot; mora stajati na kraju reda ako se prelama red. Naredni kod ne radi kako treba: ggplot(data = gapminder2007, aes(x = gdpPercap, y = lifeExp)) + geom_point() ## Error: Cannot use `+.gg()` with a single argument. Did you accidentally put + on a new line? 1.2 Razni primeri grafika Sada ćemo prikazati nekoliko vrsta grafika koji se mogu crtati. Gledaćemo scatterplotove, linijske grafike, histograme, boks plotove i bar plotove. Prevode sa engleskog ćemo možda smisliti. 1.2.1 Scatterplotovi Ovi grafici su grafici koji prikazuju podatke kao tačke u ravni. Prikazaćemo nekoliko primera i navesti nekoliko svojstava koja se mogu menjati. Ne možemo preći sve jer ih je previše. Geometrijski objekat, tj. funkcija koja se koristi u ove svrhe je geom_point. Koristićemo za početak podatke mpg, dostupne u paketu ggplot2. Opis podataka dobijamo pozivom ?mpg (mora biti učitan paket ggplot2). Pogledajmo šta ima u njima. mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows Napravimo običan scatterplot koji prikazuje potrošnju automobila u odnosu na zapreminu motora. Potrošnja (na autoputu) hwy je u miljama po galonu, a zapremina motora displ u litrima. Dakle, što je manja mpg, auto više troši. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() Vidimo da postoji opadajući trend, tj. što veći motor imamo, potrošnja goriva raste, ali imamo neke tačke koje odstupaju od trenda pri desnom kraju slike. Unesimo malo boje u grafik da probamo da vidimo šta se dešava. Možemo da probamo da nadjemo klastere u podacima na osnovu klase vozila (kombi, SUV, mali auto, sportski itd.), koja nam je data u promenljivoj class u podacima. To prosto radimo tako što dodamo estetski parametar color = class u geom_point poziv. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) Vidimo da su ove tačke što odstupaju zapravo sportski automobili (2seater), koji imaju mnogo velike motore a malu masu, pa im je potrošnja manja nego od SUV, pikap i minivan vozila, koji vidimo da su pri dnu grafika. Možemo da napravimo grafik tako da i veličinu tačke stavi u zavisnosti koliko cilindara ima motor. Opet, samo dodamo estetski parametar size = cyl. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class, size = cyl)) Grafik je pomalo smešan, ali se vidi da veliki potrošaći imaju motore sa više cilindara. Može se menjati i oblik tačkica prosledjivanjem estetskog parametra shape. Sada u zavisnosti od tipa pogona (prednji, zadnji, sva 4 točka) imamo različit oblik. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class, shape = drv)) Ovde su tačke dosta sitne i ne vide se lepo oblici, tako da možemo povećati sve tačke dodavanjem argumenta size samoj funkciji geom_point. Napomena! Ne dodajemo argument unutar aes nego van aes a unutar geom_point. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) Sad je sve uočljivije. Vidimo da sportska kola (crvena) imaju uvek zadnji pogon. Ono što je vrlo lepo kod ggplot-a je što se mogu koristiti i neke statističke funkcije. Na primer, možemo docrtati i liniju koja opisuje trend u podacima korišćenjem funkcije geom_smooth, koja napravi odredjenu aproksimaciju podataka (npr. linearni model, neki polinom i sl.) i nacrta je. Obogatimo grafik dodatno… ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Podrazumevano je da geom_smooth koristi metodu “loess” kao aproskimaciju koja nam daje nelinearnu ocenu trenda. Najjednostavnija ocena trenda je da provučemo pravu kroz podatke korišćenjem linearne regresije. To radimo davanjem argumenta method = &quot;lm&quot; funkciji geom_smooth. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) + geom_smooth(method = &quot;lm&quot;) Dobili smo najbolju pravu kroz podatke. Kao bonus imamo i traku poverenja. Da se vratimo početnom grafiku, sada znate da protumačite kod… gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) Često je korisno kod ovakvih podataka koji imaju nagli rast pa onda skoro konstantan nivo promeniti skalu da gledamo logaritam od x ose, čime se trend pretvori u linearniji. To možemo lako da uradimo tako što dodamo i komponentu skaliranja x ose sa scale_x_continuous. Promenićemo i naslov za x osu sa funkcijom xlab. ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) + scale_x_continuous(trans = &quot;log&quot;) + xlab(&quot;log(gdpPercap)&quot;) Sada se malo lakše vide neki podaci i više nisu u gužvi. 1.2.2 Linijski grafici Za crtanje vremenski uredjenih podataka, poput vremenskih serija, standardni grafici su linijski. To je prosto linija koja prikazuje kretanje neke promenljive kroz vreme. Za primer koristićemo skup podataka economics iz paketa ggplot2. Nacrtaćemo kretanje promenljive “psavert” kroz vreme ggplot(economics, aes(x = date, y = psavert)) + geom_line() Možemo i ovde dodati ocenu trenda ggplot(economics, aes(x = date, y = psavert)) + geom_line() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Napredniji primer Možemo i promeniti podeoke na x osi da budu meseci pored godina, kao i da budu prikazan tekst za svaku petu goinu na x osi sa funkcijom scale_x_date (“%b” u formatu oznacava mesec a “%Y” godinu, ovde vidite sve formate za datume). Nazive osa menjamo funkcijom labs. ggplot(economics, aes(x = date, y = psavert)) + geom_line(color = &quot;darkgreen&quot;) + geom_smooth() + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%b %Y&quot;) + labs(x = &quot;Mesec&quot;, y = &quot;Stopa stednje&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 1.2.3 Histogrami Gruba ocena raspodele uzorka se može vizuelizovati histogramima, gde brojimo koliko elemenata uzorka upada u odgovarajuće kategorije. U R-u ugradjena funkcija hist crta histograme, dok se u ggplot2 za to koristi geometrijski objekat geom_histogram. Pripremimo prvo podatke koje ćemo da koristimo za primer. Koristićemo podatke o temperaturi iz baze weather iz paketa nycflights13, pri čemu ćemo uzeti podatke samo za 26.02.2013. Takodje ćemo pretvoriti temperaturu iz farenhajta u celzijuse. library(nycflights13) # dodajemo kolonu u kojoj je temperatura po celzijusovoj skali weather$celsius &lt;- (weather$temp - 32) * 5 / 9 weather_today &lt;- weather[weather$month == 2 &amp; weather$day == 26, ] Sada da nacrtamo histogram library(ggplot2) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Obaveštava nas da je podrazumevano da se koristi 30 kategorija, pa je histogram dosta loš. Možemo promeniti broj kategorija ili širinu kategorija. Promenimo broj kategorija na 10. ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = 10) Sada nemamo problem sa brojem kategorija, ali histogram nije jasno vidljiv. Zato ćemo da uradimo najbitniji deo vizuelizacije - da ga obojimo. Stavićemo granice izmedju kolona bele boje i obojićemo kolone u plavo (sve moguće boje vidite pozivanjem colors()). ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = 10, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Ovo je već mnogo lepše.Uporedimo sa histogramom iz R-a. hist(weather_today$celsius) U R-u je podrazumevano da broj kategorija uzme kao \\(\\lceil \\log_2n + 1\\rceil\\), što se dobija pozivom nclass.Sturges funkcije. Odaberimo i mi broj kategorija po Sturges-ovoj formuli. bin_count &lt;- nclass.Sturges(weather_today$celsius) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = bin_count, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Sada su histogrami slični ali opet nisu isti. To je zato što intervali u našem histogramu ne počinju od nule nego su malo pomereni ulevo, dok su u R-u u rasponu od 0 do 7. Gledanjem izvornog koda funkcije hist (pokretanjem hist.default u konzoli), vidimo da sledećim kodom R odredjuje granice intervala za kategorije pretty(range(x), n = breaks, min.n = 1). To ćemo i mi sada iskoristiti. bin_count &lt;- nclass.Sturges(weather_today$celsius) R_breaks &lt;- pretty(range(weather_today$celsius), n = bin_count, min.n = 1) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(breaks = R_breaks, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Sada imamo isti histogram kao ugradjen u R! Cilj ovolike priče je da se vidi da je histogram vrlo osetljiv na odabir broja kategorija i tačne lokacije kategorija. Zato ggplot2 insistira na tome da se ručno podese sve željene vrednosti kod histograma i ne daje nikakve smislene podrazumevane vrednosti, da bi se korisnik ohrabrio da napravio histogram koji mu najlepše izgleda i koji najbolje oslikava priču koju želi da prenese podacima. 1.2.4 Crtanje više grafika odjednom Pre prelaska na boks plotove, pogledajmo ukratko kako možemo da pravimo više grafika odjednom, koji su rasporedjeni u mrežu. Za to koristimo funkciju facet_wrap. Nacrtaćemo histograme za različite mesece. ggplot(weather, aes(x = celsius)) + geom_histogram(color = &quot;white&quot;, fill = &quot;steelblue&quot;) + facet_wrap(~ month) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1 rows containing non-finite values (stat_bin). Odavde možemo da vidimo kako se razlikuju raspodele temperature po mesecima. Kao što je očekivano, raspodele u zimskim mesecima su pomerene ulevo u odnosu na letnje. 1.2.5 Boks plotovi U nekim slučajevima bolji način za poredjenje raspodela nam mogu omogućiti boks plotovi. Boks plot predstavlja grafički prikaz 5 sumarnih statistika - minimum, 1. kvartil, medijanu, 3. kvartil i maksimum. Te vrednosti dobijamo i pokretanjem funkcije summary na uzorku. summary(weather_today$celsius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 2.20 3.60 3.61 5.15 6.70 Boks plot se generiše funkcijom geom_boxplot. kada crtamo boks plot za jedan uzorak, dovoljno je dati samo y osu. ggplot(weather_today, aes(y = celsius)) + geom_boxplot() Boks plot se tumači ovako: Linija u sredini pravougaonika predstavlja medijanu. Gornja i donja ivica pravougaonika predstavljaju, redom, 3. i 1. kvartil. Linije koje idu izvan pravougaonika oslikavaju opseg uzorka, tj. idu od minimuma do maksimuma. Tačnije, obično se ne crtaju potpuno od minimuma do maksimuma, već su dužine \\(1.5 \\cdot IQR\\) (interkvartilno rastojanje - visina pravougaonika). Vrlo korisno svojstvo funkcije geom_boxplot je što može da koristi i x osu, koja mora biti kategorička, tj. faktor. Pogledajmo rezultat ako dodamo mesec, pretvoren u kategoričku promenljivu, kao x osu. ggplot(weather, aes(y = celsius, x = factor(month))) + geom_boxplot() ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). Dobili smo boks plotove za pojedinačne mesece! Sada možemo da uporedimo raspodele. Opet se vidi razlika u raspodeli temperature u letnjim mesecima. Jasnije se vidi i kako se temperatura menja kroz godinu. Tačke koje se vide van linija su neka vrsta autlajera, one iskaču van \\(1.5 \\cdot IQR\\) od ivica pravougaonika. Lepši opis strukture boks plotova može se naći npr. na https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51 1.2.6 Bar plotovi Bar plotovi nam služe za grafički prikaz kategoričkih promenljivih. Na njima se prikazuje koliko postoji podataka u bazi iz odgovarajuće kategorije. Razlikuju se od histograma po tome što ne svrstavaju podatke po kategorijama u zavisnosti od toga kom intervalu pripadaju njihove numeričke vrednosti, već prosto broje članove kategorija. Takodje, zbog prirode podataka, ne postoji uredjenje, pa nisu sa leve strane grafika “manje” vrednosti nego sa desne. U ggplot2 bar plotove crtamo sa funkcijom geom_bar. Takodje je dovoljno dati samo x osu. Probrojmo iz baze mpg broj podataka po klasi. ggplot(mpg, aes(x = class)) + geom_bar() Ovo je sivo i mora se obojiti ggplot(mpg, aes(x = class)) + geom_bar(fill = &quot;forestgreen&quot;, color = &quot;black&quot;) Nekad nećemo da prebrojimo elemente neke kategorije, već imamo u podacima za odredjenu kategoričku promenljivu dodeljenu neku vrednost. Na primer, u podacima gapminder imamo države i njihove populacije, pa možemo da nacrtamo populaciju po državama. To radimo funkcijom geom_col kojoj pored x ose dodamo i y osu sa odgovarajućim vrednostima. library(gapminder) # napravimo kratak spisak drzava koj cemo gledati countries &lt;- c(&quot;Bosnia and Herzegovina&quot;, &quot;Croatia&quot;, &quot;Montenegro&quot;, &quot;Serbia&quot;, &quot;Slovenia&quot;) gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] gapminder_small &lt;- gapminder2007[gapminder2007$country %in% countries, ] ggplot(gapminder_small, aes(x = country, y = pop)) + geom_col(fill = &quot;forestgreen&quot;, color = &quot;black&quot;) Bar plotovi mogu biti i naslagani, da prikazuju više vrednosti za istu kategoriju odjednom. Lakše se vidi na primeru. Nacrtaćemo bar plot gde se vidi populacija za 1997., 2002. i 2007. godinu. library(gapminder) gapminder567 &lt;- gapminder[(gapminder$year %in% c(1997, 2002, 2007)) &amp; (gapminder$country %in% countries), ] ggplot(gapminder567, aes(x = country, y = pop)) + geom_col(color = &quot;black&quot;, mapping = aes(fill = factor(year))) Ovi grafici nisu laki za čitanje jer je teško uporediti veličine pravougaonika raznih boja. Korisnija alternativa se dobije kada se doda argument position = &quot;dodge&quot; ggplot(gapminder567, aes(x = country, y = pop)) + geom_col(color = &quot;black&quot;, mapping = aes(fill = factor(year)), position = &quot;dodge&quot;) Sada vidimo za sve godine kretanje populacije u državama i lakše je za poredjenje. Sve navedeno za geom_col može se odraditi za geom_bar ako se radi prebrojavanje odgovarajućih kategorija. Na primer, možemo prikazati broj letova iz paketa nycflights13 po kompanijama u zavisnosti od polazišta. ggplot(flights, aes(x = carrier, fill = origin)) + geom_bar(position = &quot;dodge&quot;) Ovime smo prešli sve osnovne grafike. "],
["rad-sa-podacima.html", "2 Rad sa podacima 2.1 Dataframe 2.2 Obrada podataka - dplyr paket", " 2 Rad sa podacima U ovom poglavlju ćemo se upoznati sa osnovnim metodama rada sa podacima, prvenstveno kroz paket dplyr, koji je jedan od najkorišćenijih paketa u R-u. Pre upoznavanja sa tim paketom, osnvrnućemo se na osnovnu strukturu podataka u R-u, dataframe, koja se koristi za rad sa tabelarnim podacima. 2.1 Dataframe Dataframe je najčešći način čuvanja podataka u R-u i vrlo je pogodan za rad i analizu. Služi za prikaz tabelarnih podataka, pa liči na matricu, s tim što je dataframe u snovi lista koja sadrži vektore jednakih dužina (kolone), pri čemu ti vektori ne moraju biti istog tipa. Dakle možemo imati jednu kolonu koju čine brojevi, a drugu tekstualni podaci. Dataframe se pravi na sledeći način: df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;)) df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Ovako smo dobili dataframe sa dve kolone, od kojih je jedna numeri;ka a druga tekstualna. str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: Factor w/ 3 levels &quot;drugi&quot;,&quot;prvi&quot;,..: 2 1 3 R podrazumevano pretvara tekstualne podatke u faktore, to možemo preduprediti ako dodamo argument stringsAsFactors = FALSE df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: chr &quot;prvi&quot; &quot;drugi&quot; &quot;treci&quot; df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Dva dataframe-a (koji imaju isi broj kolona) se mogu spojiti da dobijemo više kolona korišćenjem funkcije cbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona3 = c(4,5,6), kolona4 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df3 &lt;- cbind(df1, df2) df3 ## kolona1 kolona2 kolona3 kolona4 ## 1 1 prvi 4 prvi1 ## 2 2 drugi 5 drugi1 ## 3 3 treci 6 treci1 Takodje, mogu se nadovezati po vrstama (ako imaju ista imena kolona) funkcijom rbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona1 = c(4,5,6), kolona2 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df4 &lt;- rbind(df1, df2) df4 ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Vrednostima kolona možemo pristupati pomoću operatora $, kao u listama, a istim možemo i dodati nove kolone. df$kolona1 ## [1] 1 2 3 df$kolona5 &lt;- c(7,8,9) df ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 Medjutim, možda elegantniji način filtriranja i odabira podskupova dataframe-a je korišćenjem uglatih zagrada. Koristimo notaciju df[redovi, kolone], gde prvim argumentom odredjujemo koje redove želimo da uzmemo, a drugim koje kolone. Prazno mesto za neki od argumenata znači “uzmi sve”. df[,] # sve ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 df[1,] # prva vrsta ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 df[,1] # prva kolona ## [1] 1 2 3 Redovi mogu biti ili vektori brojeva koji označavaju indekse redova koje da uzmemo, ili vektori TRUE/FALSE vrednosti iste dužine kao broj vrsta u dataframe-u, pri čemu se tada biraju redovi na pozicijama gde je u vektoru vrednost TRUE. df4[c(1,3,4), ] # sve kolone, redovi 1,3,4 ## kolona1 kolona2 ## 1 1 prvi ## 3 3 treci ## 4 4 prvi1 df4[df4$kolona1 &gt; 3, ] # sve kolone, one vrste kod kojih je kolona1 veca od 3 ## kolona1 kolona2 ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Kolone mogu biti ili vektori brojeva koji označavaju koje kolone da uzmemo prema indeksu, ili vektori stringova, koji označavaju imena kolona koje da uzmemo. df3[, c(1,3)] # sve vrste, 1 i 3 kolona ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[, c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # isto ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[c(1,3), c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # prvi i treci red, prva i treca kolona ## kolona1 kolona3 ## 1 1 4 ## 3 3 6 Korisna stvar je da ako koristimo vektore brojeva za indeksiranje, ukoliko stavimo znak - ispred, to znači da izuzimamo te redove/kolone. df[, -1] # sve bez prve kolone ## kolona2 kolona5 ## 1 prvi 7 ## 2 drugi 8 ## 3 treci 9 df[-2, ] # sve bez druge vrste ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 3 3 treci 9 df[-c(1,2), c(&quot;kolona2&quot;, &quot;kolona5&quot;)] # druga i peta kolona, bez prve i druge vrste ## kolona2 kolona5 ## 3 treci 9 Konačno, za osnovne informacije o tabeli postoje funkcije colnames, rownames, ncol i nrow, za koje možete pretpostaviti šta rade. 2.2 Obrada podataka - dplyr paket Prethodno navedeni način rada sa tabelarnim podacima učitanim kao dataframe može postati prilično nezgrapan kod komplikovanijih zahteva, pa je stoga smišljen mnogo elegantniji pristup pomoću paketa dplyr. Uvodni tutorijal za paket možete naći i na https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html. Zansnovan je na korišćenju nekoliko osnovnih radnji koje se primenjuju na podacima, koje su implementirane funkcijama: select - biranje kolona iz tabele filter - filtriranje vrsta tabele arrange - sortiranje vrsta na osnovu nekih kolona mutate - pravljenje novih kolona korišćenjem postojećih summarise - računanje neke sumarne statistike (grupisanih) podataka Postoji i mnogo više funkcija u ovom paketu, koje su često slične navedenim i koje ćemo kad za to bude potrebe pokazati. Uz ovaj paket se upotrebljava malo čunija sintaksa, zasnovana na korišćenju operatora kompozicije %&gt;%. Najlakše ćemo pokazati primerom šta on radi. Uzmimo pomoću paketa dplyr kolonu 1 iz našeg dataframe-a. library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df %&gt;% select(kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Ovo je ekvivalentno pozivu select(df, kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Operator %&gt;% radi tako što prosledjuje levi operand kao prvi argument funkcije date sa desne strane operatora, pa ostale argumente prosledjuje kao dodatne. Suštinski, kod x %&gt;% f(y) postaje f(x, y). Ako želimo da specifikujemo gde hoćemo da stavimo levu stranu operatora, koristimo .. Na primer, gornji kod je ekvivalentan df %&gt;% select(., kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Vremenom će postati ovakva sintaksa prirodna. Vrlo je elegantna jer omogućava jednostavno nadovezivanje. Na sledeći način iz df izaberemo prve dve kolone i filtriramo da uzmemo vrste gde je prva kolona veća od 1. df %&gt;% select(kolona1, kolona2) %&gt;% filter(kolona1 &gt; 1) ## kolona1 kolona2 ## 1 2 drugi ## 2 3 treci Ovime smo videli već primere korišćenja dve funkcije u dplyr paketu - select i filter. 2.2.1 Učitavanje eksternih podataka Prikažimo mogućnosti paketa dplyr kroz istraživanje podataka o životnom veku u državama, poteklih od Svetske zdravstvene organizacije. Podaci koje ćemo posmatrati su dostupni na https://www.kaggle.com/kumarajarshi/life-expectancy-who. Kada preuzmemo podatke, učitavamo ih funkcijom read.csv: who_data &lt;- read.csv(&quot;Life Expectancy Data.csv&quot;) who_data %&gt;% sample_n(15) # stampamo 15 slucajno izabranih ## Country Year Status Life.expectancy Adult.Mortality ## 1 Canada 2012 Developing 81.6 68 ## 2 Côte d&#39;Ivoire 2008 Developing 54.0 437 ## 3 Mauritania 2012 Developing 62.5 29 ## 4 Vanuatu 2009 Developing 78.0 149 ## 5 Brazil 2009 Developing 73.6 157 ## 6 Russian Federation 2010 Developing 68.4 256 ## 7 Brunei Darussalam 2010 Developing 76.9 79 ## 8 Israel 2011 Developing 81.8 61 ## 9 South Africa 2001 Developing 56.0 429 ## 10 Solomon Islands 2001 Developing 66.2 227 ## 11 Mexico 2015 Developing 76.7 122 ## 12 Thailand 2010 Developing 73.9 158 ## 13 Libya 2003 Developing 71.3 144 ## 14 Georgia 2014 Developing 74.5 125 ## 15 Turkmenistan 2003 Developing 63.4 231 ## infant.deaths Alcohol percentage.expenditure Hepatitis.B Measles BMI ## 1 2 8.30 9748.63624 7 10 65.3 ## 2 60 2.69 0.00000 74 12 23.8 ## 3 8 0.01 62.48420 8 35 28.8 ## 4 0 0.83 361.09410 62 0 48.2 ## 5 57 7.33 564.52339 99 0 51.1 ## 6 15 11.05 162.80881 97 129 57.5 ## 7 0 0.88 2218.36423 96 0 36.2 ## 8 1 2.67 3793.16162 98 70 63.4 ## 9 52 7.38 365.25857 72 1166 4.9 ## 10 0 0.70 325.11147 83 0 38.7 ## 11 30 NA 0.00000 82 0 63.5 ## 12 10 5.95 71.68509 98 2583 27.9 ## 13 3 0.01 295.11665 96 0 54.6 ## 14 1 6.13 221.48288 91 3188 55.3 ## 15 7 2.88 179.61565 97 1 39.4 ## under.five.deaths Polio Total.expenditure Diphtheria HIV.AIDS ## 1 2 99 1.78 95 0.1 ## 2 85 58 6.21 74 4.1 ## 3 12 8 3.36 8 1.2 ## 4 0 66 3.90 66 0.1 ## 5 64 99 8.65 99 0.1 ## 6 17 98 6.83 97 0.2 ## 7 0 99 2.73 95 0.1 ## 8 1 94 7.39 94 0.1 ## 9 76 71 8.31 71 24.0 ## 10 0 88 6.44 84 0.1 ## 11 35 87 NA 87 0.1 ## 12 12 99 3.81 99 0.2 ## 13 3 95 4.60 95 0.1 ## 14 1 91 7.42 91 0.1 ## 15 8 66 3.85 83 0.1 ## GDP Population thinness..1.19.years thinness.5.9.years ## 1 52496.6949 3475545 0.5 0.5 ## 2 NA NA 6.6 6.6 ## 3 1364.2837 383239 8.3 8.1 ## 4 2643.4414 23785 1.5 1.5 ## 5 8553.3847 194895996 3.0 2.9 ## 6 1674.9877 142849449 2.3 2.5 ## 7 35268.1117 NA 5.9 5.4 ## 8 33657.1573 77658 1.2 1.1 ## 9 2681.7810 45312937 15.4 18.1 ## 10 944.8168 423853 1.4 1.4 ## 11 9143.1285 12589949 1.5 1.5 ## 12 575.3218 672888 8.2 8.3 ## 13 4676.9675 NA 5.6 5.4 ## 14 4429.6575 3727 2.7 2.8 ## 15 1283.8860 4655741 3.5 3.4 ## Income.composition.of.resources Schooling ## 1 0.907 15.9 ## 2 NA NA ## 3 0.491 7.8 ## 4 0.589 10.7 ## 5 0.714 13.8 ## 6 0.773 13.7 ## 7 0.845 14.2 ## 8 0.883 15.8 ## 9 0.629 13.0 ## 10 0.442 6.6 ## 11 0.758 13.3 ## 12 0.711 13.1 ## 13 0.740 16.0 ## 14 0.759 13.5 ## 15 0.000 10.3 Paket dplyr koristi malo bogatiju strukturu umesto dataframe-a za tabelarne podatke, a to je tibble. Podatke pretvaramo u taj format na sledeći način: who_data &lt;- as_tibble(who_data) who_data ## # A tibble: 2,938 x 22 ## Country Year Status Life.expectancy Adult.Mortality infant.deaths ## &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghan… 2015 Devel… 65 263 62 ## 2 Afghan… 2014 Devel… 59.9 271 64 ## 3 Afghan… 2013 Devel… 59.9 268 66 ## 4 Afghan… 2012 Devel… 59.5 272 69 ## 5 Afghan… 2011 Devel… 59.2 275 71 ## 6 Afghan… 2010 Devel… 58.8 279 74 ## 7 Afghan… 2009 Devel… 58.6 281 77 ## 8 Afghan… 2008 Devel… 58.1 287 80 ## 9 Afghan… 2007 Devel… 57.5 295 82 ## 10 Afghan… 2006 Devel… 57.3 295 84 ## # … with 2,928 more rows, and 16 more variables: Alcohol &lt;dbl&gt;, ## # percentage.expenditure &lt;dbl&gt;, Hepatitis.B &lt;int&gt;, Measles &lt;int&gt;, ## # BMI &lt;dbl&gt;, under.five.deaths &lt;int&gt;, Polio &lt;int&gt;, ## # Total.expenditure &lt;dbl&gt;, Diphtheria &lt;int&gt;, HIV.AIDS &lt;dbl&gt;, GDP &lt;dbl&gt;, ## # Population &lt;dbl&gt;, thinness..1.19.years &lt;dbl&gt;, ## # thinness.5.9.years &lt;dbl&gt;, Income.composition.of.resources &lt;dbl&gt;, ## # Schooling &lt;dbl&gt; Vidimo blage razlike u prikazu. Korisno je pogledati podatke funkcijom glimpse (iz dplyr), gde vidimo tip promenljivih i prvih nekoliko podataka iz odgovarajuće kolone. glimpse(who_data) ## Observations: 2,938 ## Variables: 22 ## $ Country &lt;fct&gt; Afghanistan, Afghanistan, Afghan… ## $ Year &lt;int&gt; 2015, 2014, 2013, 2012, 2011, 20… ## $ Status &lt;fct&gt; Developing, Developing, Developi… ## $ Life.expectancy &lt;dbl&gt; 65.0, 59.9, 59.9, 59.5, 59.2, 58… ## $ Adult.Mortality &lt;int&gt; 263, 271, 268, 272, 275, 279, 28… ## $ infant.deaths &lt;int&gt; 62, 64, 66, 69, 71, 74, 77, 80, … ## $ Alcohol &lt;dbl&gt; 0.01, 0.01, 0.01, 0.01, 0.01, 0.… ## $ percentage.expenditure &lt;dbl&gt; 71.279624, 73.523582, 73.219243,… ## $ Hepatitis.B &lt;int&gt; 65, 62, 64, 67, 68, 66, 63, 64, … ## $ Measles &lt;int&gt; 1154, 492, 430, 2787, 3013, 1989… ## $ BMI &lt;dbl&gt; 19.1, 18.6, 18.1, 17.6, 17.2, 16… ## $ under.five.deaths &lt;int&gt; 83, 86, 89, 93, 97, 102, 106, 11… ## $ Polio &lt;int&gt; 6, 58, 62, 67, 68, 66, 63, 64, 6… ## $ Total.expenditure &lt;dbl&gt; 8.16, 8.18, 8.13, 8.52, 7.87, 9.… ## $ Diphtheria &lt;int&gt; 65, 62, 64, 67, 68, 66, 63, 64, … ## $ HIV.AIDS &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.… ## $ GDP &lt;dbl&gt; 584.25921, 612.69651, 631.74498,… ## $ Population &lt;dbl&gt; 33736494, 327582, 31731688, 3696… ## $ thinness..1.19.years &lt;dbl&gt; 17.2, 17.5, 17.7, 17.9, 18.2, 18… ## $ thinness.5.9.years &lt;dbl&gt; 17.3, 17.5, 17.7, 18.0, 18.2, 18… ## $ Income.composition.of.resources &lt;dbl&gt; 0.479, 0.476, 0.470, 0.463, 0.45… ## $ Schooling &lt;dbl&gt; 10.1, 10.0, 9.9, 9.8, 9.5, 9.2, … Sumarne podatke po kolonama vidimo ugradjenom funkcijom summary. summary(who_data) ## Country Year Status ## Afghanistan : 16 Min. :2000 Developed : 512 ## Albania : 16 1st Qu.:2004 Developing:2426 ## Algeria : 16 Median :2008 ## Angola : 16 Mean :2008 ## Antigua and Barbuda: 16 3rd Qu.:2012 ## Argentina : 16 Max. :2015 ## (Other) :2842 ## Life.expectancy Adult.Mortality infant.deaths Alcohol ## Min. :36.30 Min. : 1.0 Min. : 0.0 Min. : 0.0100 ## 1st Qu.:63.10 1st Qu.: 74.0 1st Qu.: 0.0 1st Qu.: 0.8775 ## Median :72.10 Median :144.0 Median : 3.0 Median : 3.7550 ## Mean :69.22 Mean :164.8 Mean : 30.3 Mean : 4.6029 ## 3rd Qu.:75.70 3rd Qu.:228.0 3rd Qu.: 22.0 3rd Qu.: 7.7025 ## Max. :89.00 Max. :723.0 Max. :1800.0 Max. :17.8700 ## NA&#39;s :10 NA&#39;s :10 NA&#39;s :194 ## percentage.expenditure Hepatitis.B Measles BMI ## Min. : 0.000 Min. : 1.00 Min. : 0.0 Min. : 1.00 ## 1st Qu.: 4.685 1st Qu.:77.00 1st Qu.: 0.0 1st Qu.:19.30 ## Median : 64.913 Median :92.00 Median : 17.0 Median :43.50 ## Mean : 738.251 Mean :80.94 Mean : 2419.6 Mean :38.32 ## 3rd Qu.: 441.534 3rd Qu.:97.00 3rd Qu.: 360.2 3rd Qu.:56.20 ## Max. :19479.912 Max. :99.00 Max. :212183.0 Max. :87.30 ## NA&#39;s :553 NA&#39;s :34 ## under.five.deaths Polio Total.expenditure Diphtheria ## Min. : 0.00 Min. : 3.00 Min. : 0.370 Min. : 2.00 ## 1st Qu.: 0.00 1st Qu.:78.00 1st Qu.: 4.260 1st Qu.:78.00 ## Median : 4.00 Median :93.00 Median : 5.755 Median :93.00 ## Mean : 42.04 Mean :82.55 Mean : 5.938 Mean :82.32 ## 3rd Qu.: 28.00 3rd Qu.:97.00 3rd Qu.: 7.492 3rd Qu.:97.00 ## Max. :2500.00 Max. :99.00 Max. :17.600 Max. :99.00 ## NA&#39;s :19 NA&#39;s :226 NA&#39;s :19 ## HIV.AIDS GDP Population ## Min. : 0.100 Min. : 1.68 Min. :3.400e+01 ## 1st Qu.: 0.100 1st Qu.: 463.94 1st Qu.:1.958e+05 ## Median : 0.100 Median : 1766.95 Median :1.387e+06 ## Mean : 1.742 Mean : 7483.16 Mean :1.275e+07 ## 3rd Qu.: 0.800 3rd Qu.: 5910.81 3rd Qu.:7.420e+06 ## Max. :50.600 Max. :119172.74 Max. :1.294e+09 ## NA&#39;s :448 NA&#39;s :652 ## thinness..1.19.years thinness.5.9.years Income.composition.of.resources ## Min. : 0.10 Min. : 0.10 Min. :0.0000 ## 1st Qu.: 1.60 1st Qu.: 1.50 1st Qu.:0.4930 ## Median : 3.30 Median : 3.30 Median :0.6770 ## Mean : 4.84 Mean : 4.87 Mean :0.6276 ## 3rd Qu.: 7.20 3rd Qu.: 7.20 3rd Qu.:0.7790 ## Max. :27.70 Max. :28.60 Max. :0.9480 ## NA&#39;s :34 NA&#39;s :34 NA&#39;s :167 ## Schooling ## Min. : 0.00 ## 1st Qu.:10.10 ## Median :12.30 ## Mean :11.99 ## 3rd Qu.:14.30 ## Max. :20.70 ## NA&#39;s :163 2.2.2 Osnovne funkcije paketa dplyr Proći ćemo nekoliko primera osnovnih funkcija iz paketa. Najviše ćemo koristiti podatke iz paketa nycflights13, pa ga učitavamo library(nycflights13) Prelazimo na pregled funkcija. 2.2.2.1 select - odabir kolona Sa ovom funkcijom smo se već susreli i nećemo dužiti. Ona služi da iz tabele koja ima mnogo kolona odaberemo samo one koje su nam od interesa, radi lakšeg pregleda. Odaberimo iz baze flights samo kolone godina, mesec, dan, polazipte i destinacija. flights %&gt;% select(year, month, day, origin, dest) ## # A tibble: 336,776 x 5 ## year month day origin dest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 EWR IAH ## 2 2013 1 1 LGA IAH ## 3 2013 1 1 JFK MIA ## 4 2013 1 1 JFK BQN ## 5 2013 1 1 LGA ATL ## 6 2013 1 1 EWR ORD ## 7 2013 1 1 EWR FLL ## 8 2013 1 1 LGA IAD ## 9 2013 1 1 JFK MCO ## 10 2013 1 1 LGA ORD ## # … with 336,766 more rows 2.2.2.2 filter - Filtriranje redova Ova funkcija služi za odabir odgovarajućih vrsta tabele, tj. opservacija, na osnovu željenih kriterijuma. Kao primer, možemo da izdvojimo iz baze letova one letove koji idu ka Portlandu, sa kodom aerodroma &quot;PDX&quot;. portland_flights &lt;- flights %&gt;% filter(dest == &quot;PDX&quot;) #View(portland_flights) Kao argument funkciji filter prosledjuje se uslov koji želimo da ispunjavaju redovi koje biramo. To je zapravo vektor TRUE i FALSE vrednosti, kao kod indeksiranja klasičnog dataframe-a. Ovde smo koristili operator jednakosti ==, ali možemo koristiti i druge matematičke operatore poput &gt;, &lt;, &gt;=, &lt;=, !=. Više kriterijuma možemo spajati operatorima konjukcije &amp; (‘i’) i disjunkcije | (‘ili’). Naravno, pored ovih, mogu se koristiti bilo koje funkcije koje daju kao rezultat logičke vektore. Na primer, možemo da odaberemo letove koji kreću sa aerodroma JFK, a leteli su duže od sat vremena. flights %&gt;% filter(origin == &quot;JFK&quot; &amp; air_time &gt; 60) ## # A tibble: 86,058 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 542 540 2 923 ## 2 2013 1 1 544 545 -1 1004 ## 3 2013 1 1 557 600 -3 838 ## 4 2013 1 1 558 600 -2 849 ## 5 2013 1 1 558 600 -2 853 ## 6 2013 1 1 558 600 -2 924 ## 7 2013 1 1 606 610 -4 837 ## 8 2013 1 1 611 600 11 945 ## 9 2013 1 1 613 610 3 925 ## 10 2013 1 1 615 615 0 1039 ## # … with 86,048 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Odredimo sve letove sa JFK do Berlingtona (BTV) i Sijetla (SEA), koji su od oktobra do kraja godine. btv_sea_flights &lt;- flights %&gt;% filter(origin == &quot;JFK&quot; &amp; (dest == &quot;BTV&quot; | dest == &quot;SEA&quot;) &amp; month &gt;= 10) #View(btv_sea_flights) Umesto korišćenja operatora konjunkcije, možemo samo razdvojiti sve uslove koji moraju biti zadovoljeni sa zapetom. btv_sea_flights &lt;- flights %&gt;% filter(origin == &quot;JFK&quot;, (dest == &quot;BTV&quot; | dest == &quot;SEA&quot;), month &gt;= 10) #View(btv_sea_flights) 2.2.2.3 arrange - sortiranje redova Često ima smisla sortirati podatke u odnosu na neku kolonu prilikom istraživanja podataka. Paket dplyr nam daje jednostavan način za to kroz funkciju arrange. Par jednostavnih primera sledi. Sortirajmo letove po trajanju leta rastuće… flights %&gt;% arrange(air_time) %&gt;% select(tailnum, air_time) ## # A tibble: 336,776 x 2 ## tailnum air_time ## &lt;chr&gt; &lt;dbl&gt; ## 1 N16911 20 ## 2 N12167 20 ## 3 N27200 21 ## 4 N13913 21 ## 5 N13955 21 ## 6 N12921 21 ## 7 N947UW 21 ## 8 N8501F 21 ## 9 N12160 21 ## 10 N16987 21 ## # … with 336,766 more rows … ili opadajuće flights %&gt;% arrange(desc(air_time)) %&gt;% select(tailnum, air_time) ## # A tibble: 336,776 x 2 ## tailnum air_time ## &lt;chr&gt; &lt;dbl&gt; ## 1 N77066 695 ## 2 N389HA 691 ## 3 N388HA 686 ## 4 N380HA 686 ## 5 N384HA 683 ## 6 N386HA 679 ## 7 N59053 676 ## 8 N380HA 676 ## 9 N386HA 675 ## 10 N76065 671 ## # … with 336,766 more rows Vrlo korisna opcija je što se sortiranje može vršiti po više promenljivih. Na primer, da bismo sortirali letove po datumu leta, počevši od najskorijeg, treba da sortiramo prvo opadajuće po mesecu, ali i one iz istog meseca treba sortirati opadajuće po danu. Ovo radimo na sledeći način # radi lakseg pregleda, uzecemo podskup od # 10 letova set.seed(1) subflights &lt;- flights %&gt;% sample_n(10) subflights %&gt;% arrange(desc(month), desc(day)) %&gt;% select(tailnum, month, day) ## # A tibble: 10 x 3 ## tailnum month day ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 N14731 12 7 ## 2 N555AA 11 14 ## 3 N722MQ 9 10 ## 4 N537JB 8 28 ## 5 N844VA 8 24 ## 6 N16559 6 1 ## 7 N509JB 5 20 ## 8 N3AEAA 4 30 ## 9 N14573 2 17 ## 10 N3767 1 24 Napomena! Obratite pažnju, bitan je redosled argumenata u arrange, ako sortiramo prvo po danu pa po mesecu, ne dobijamo željeni rezultat. subflights %&gt;% arrange(desc(day), desc(month)) %&gt;% select(tailnum, month, day) ## # A tibble: 10 x 3 ## tailnum month day ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 N3AEAA 4 30 ## 2 N537JB 8 28 ## 3 N844VA 8 24 ## 4 N3767 1 24 ## 5 N509JB 5 20 ## 6 N14573 2 17 ## 7 N555AA 11 14 ## 8 N722MQ 9 10 ## 9 N14731 12 7 ## 10 N16559 6 1 Sortirajmo letove opadajuće po datumu, ali rastuće po trajanju leta flights %&gt;% arrange(desc(month), desc(day), air_time) %&gt;% select(tailnum, month, day, air_time) ## # A tibble: 336,776 x 4 ## tailnum month day air_time ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 N952UW 12 31 28 ## 2 N13975 12 31 29 ## 3 N197JB 12 31 32 ## 4 N304JB 12 31 32 ## 5 N76514 12 31 32 ## 6 N236JB 12 31 32 ## 7 N329JB 12 31 33 ## 8 N351JB 12 31 33 ## 9 N3JAAA 12 31 33 ## 10 N206JB 12 31 33 ## # … with 336,766 more rows 2.2.2.4 mutate - dodavanje nove kolone Ovom funkcijom možemo da napravimo nove kolone koristeći postojeće. Na primer, možemo da vršimo konverziju iz Farenhajta u Celzijus. # ovako smo ranije # weather$celsius &lt;- (weather$temp - 32) * 5 / 9 # dplyr nacin: weather &lt;- weather %&gt;% mutate(celsius = (temp - 32) * 5 / 9) #View(weather) Možemo praviti više novih kolona odjednom. Na primer, dodaćemo kolonu “gain” koja predstavlja razliku izmedju kašnjenja polaska i kašnjenja dolaska, tj. neki vid nadoknadjenog vremena kada je let kasnio sa polaskom. Pored toga, dodaćemo kolonu koja predstavlja let u satima, i odrediti i “gain” po satu. flights &lt;- flights %&gt;% mutate( gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) I sortiramo po gain_per_hour flights %&gt;% arrange(gain_per_hour) %&gt;% select(dep_delay, arr_delay, gain, hours, air_time, gain_per_hour) ## # A tibble: 336,776 x 6 ## dep_delay arr_delay gain hours air_time gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 171 273 -102 0.517 31 -197. ## 2 62 177 -115 0.6 36 -192. ## 3 11 122 -111 0.6 36 -185 ## 4 115 233 -118 0.667 40 -177 ## 5 -7 106 -113 0.65 39 -174. ## 6 -8 123 -131 0.767 46 -171. ## 7 -1 109 -110 0.65 39 -169. ## 8 39 152 -113 0.7 42 -161. ## 9 3 94 -91 0.567 34 -161. ## 10 33 136 -103 0.65 39 -158. ## # … with 336,766 more rows Ako uposlimo i paket lubridate, koji značajno olakšava rad sa datumima u R-u, možemo dodati i kolonu koja sadrži tačno vreme leta, umesto komponenti koje imamo sada. #install.packages(&quot;lubridate&quot;) library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date flights &lt;- flights %&gt;% mutate(departure = make_datetime(year, month, day, hour, minute)) flights %&gt;% select(year, month, day, hour, minute, departure) ## # A tibble: 336,776 x 6 ## year month day hour minute departure ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # … with 336,766 more rows Sada prethodno sortiranje opadajuće možemo odratiti po toj novoj koloni. set.seed(1) flights %&gt;% sample_n(10) %&gt;% arrange(desc(departure)) %&gt;% select(tailnum, month, day, departure) ## # A tibble: 10 x 4 ## tailnum month day departure ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dttm&gt; ## 1 N14731 12 7 2013-12-07 14:45:00 ## 2 N555AA 11 14 2013-11-14 06:00:00 ## 3 N722MQ 9 10 2013-09-10 19:50:00 ## 4 N537JB 8 28 2013-08-28 09:01:00 ## 5 N844VA 8 24 2013-08-24 16:55:00 ## 6 N16559 6 1 2013-06-01 12:32:00 ## 7 N509JB 5 20 2013-05-20 19:05:00 ## 8 N3AEAA 4 30 2013-04-30 13:45:00 ## 9 N14573 2 17 2013-02-17 08:15:00 ## 10 N3767 1 24 2013-01-24 18:50:00 "]
]
