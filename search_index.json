[
["index.html", "Statistički softver 2 Predgovor", " Statistički softver 2 Blagoje Ivanović Poslednja izmena: 26 May, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 2. Cilj kursa je da se upoznamo sa često korišćenim alatima pri analizi podataka koristeći programski jezik R, kao i da primenimo stečena statistička znanja na podacima. Velikim delom ćemo pratiti kurs koji se nalazi na https://moderndive.com, uz odredjene izmene. Vrlo dobra literatura koju ćemo koristiti često na kursu jeste i knjiga R for Data Science, a za one koji bi da nauče nešto više o R-u, obavezna literatura je Advanced R. "],
["11-ggplot.html", "1 Grafički prikaz podataka 1.1 Uvodni primeri i napomene 1.2 Razni primeri grafika", " 1 Grafički prikaz podataka Prvo ćemo se zabavljati grafičkim prikazima podataka i crtanjem raznih grafika, koristeći paket ggplot2 koji je jedan od najupotrebljenijih paketa u R-u. Velika prednost ovog paketa je što sa vrlo malo koda možemo da pravimo dosta bogate grafike. S druge strane, ima malo čudniju sintaksu od klasičnih grafika u R-u, pa zahteva malo učenja. Medjutim ta sintaksa je prilično smislena i elegentna, kao što ćemo videti kroz rad. 1.1 Uvodni primeri i napomene Kao inicijalnu demonstraciju sile, pogledajmo sledeći grafik, na kome se vidi dosta različitih elemenata, poput raznih boja za razne promenljive, različite veličine tačaka, prikaz legende itd. ## Registered S3 methods overwritten by &#39;ggplot2&#39;: ## method from ## [.quosures rlang ## c.quosures rlang ## print.quosures rlang Kod koji generiše ovaj grafik je sledeči. Primetite da samo zadnja naredba crta grafik, pre toga je prosto smanjivanje količine podataka. library(ggplot2) library(gapminder) gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) Proći ćemo kroz sve delove ovog koda vremenom i ubrzo ćete moći da pravite ovakve grafike bez problema. Prvo ipak malo teorije. Paket ggplot2 se zasniva na takozvanoj “gramatici grafike” i uočljivo je u prethodnom kodu da se grafici prave “sabiranjem”. Zabpravo dodajemo komponentu po komponentu na grafik. Glavni delovi koje grafik ima su: Podaci (data): Skup podataka koji se prikazuje Geometrijski objekat (geom_*): Tip geometrijskog objekta kojim se prikazuju podaci. Mogu biti tačke, linije, histogrami, itd. Estetski parametri (aes()): Estetski atributi koji se mogu dodeliti geometrijskim objektima. Uvek imamo x/y koordinatu, a možemo dodati i boju, veličinu, itd. Svaki estetski parametar se može primeniti na promenljivu u podacima, pa svaki element u podacima ima svoju vrednost tog parametra (npr. gore su sve tačke iz istih kontinenata isto obojene). Grafike koristeći ggplot pravimo prateći sledeći šablon: ggplot(data = &lt;Podaci&gt;) + &lt;geom_funkcija&gt;(mapping = aes(&lt;estetski parametri&gt;)) Bitno je pomenuti da ne postoji podrazumevani grafik u ggplot, već se mora dodati neki geometrijcki objekat (pozivom neke geom_* funkcije). Pozivanjem samo ggplot(data=...) dobija se prazan grafik: ggplot(data = gapminder2007) Neki estetski parametri se mogu dodeliti i na početku, npr. odmah možemo postaviti x i y osu u pozivu ggplot, pa će ona ostati fiksna za sledeće elemente grafika. Ovako možemo nacrtati prethodni grafik (bez boja i sl.). # sablon bi bio: # ggplot(data=gapminder2007) + # geom_point(aes(x = gdpPercap, y = lifeExp)) ggplot(data = gapminder2007, aes(x = gdpPercap, y = lifeExp)) + geom_point() Vrlo bitna napomena! Znak &quot; + &quot; mora stajati na kraju reda ako se prelama red. Naredni kod ne radi kako treba: ggplot(data = gapminder2007, aes(x = gdpPercap, y = lifeExp)) + geom_point() ## Error: Cannot use `+.gg()` with a single argument. Did you accidentally put + on a new line? 1.2 Razni primeri grafika Sada ćemo prikazati nekoliko vrsta grafika koji se mogu crtati. Gledaćemo scatterplotove, linijske grafike, histograme, boks plotove i bar plotove. Prevode sa engleskog ćemo možda smisliti. 1.2.1 Scatterplotovi Ovi grafici su grafici koji prikazuju podatke kao tačke u ravni. Prikazaćemo nekoliko primera i navesti nekoliko svojstava koja se mogu menjati. Ne možemo preći sve jer ih je previše. Geometrijski objekat, tj. funkcija koja se koristi u ove svrhe je geom_point. Koristićemo za početak podatke mpg, dostupne u paketu ggplot2. Opis podataka dobijamo pozivom ?mpg (mora biti učitan paket ggplot2). Pogledajmo šta ima u njima. mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows Napravimo običan scatterplot koji prikazuje potrošnju automobila u odnosu na zapreminu motora. Potrošnja (na autoputu) hwy je u miljama po galonu, a zapremina motora displ u litrima. Dakle, što je manja mpg, auto više troši. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() Vidimo da postoji opadajući trend, tj. što veći motor imamo, potrošnja goriva raste, ali imamo neke tačke koje odstupaju od trenda pri desnom kraju slike. Unesimo malo boje u grafik da probamo da vidimo šta se dešava. Možemo da probamo da nadjemo klastere u podacima na osnovu klase vozila (kombi, SUV, mali auto, sportski itd.), koja nam je data u promenljivoj class u podacima. To prosto radimo tako što dodamo estetski parametar color = class u geom_point poziv. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) Vidimo da su ove tačke što odstupaju zapravo sportski automobili (2seater), koji imaju mnogo velike motore a malu masu, pa im je potrošnja manja nego od SUV, pikap i minivan vozila, koji vidimo da su pri dnu grafika. Možemo da napravimo grafik tako da i veličinu tačke stavi u zavisnosti koliko cilindara ima motor. Opet, samo dodamo estetski parametar size = cyl. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class, size = cyl)) Grafik je pomalo smešan, ali se vidi da veliki potrošaći imaju motore sa više cilindara. Može se menjati i oblik tačkica prosledjivanjem estetskog parametra shape. Sada u zavisnosti od tipa pogona (prednji, zadnji, sva 4 točka) imamo različit oblik. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class, shape = drv)) Ovde su tačke dosta sitne i ne vide se lepo oblici, tako da možemo povećati sve tačke dodavanjem argumenta size samoj funkciji geom_point. Napomena! Ne dodajemo argument unutar aes nego van aes a unutar geom_point. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) Sad je sve uočljivije. Vidimo da sportska kola (crvena) imaju uvek zadnji pogon. Ono što je vrlo lepo kod ggplot-a je što se mogu koristiti i neke statističke funkcije. Na primer, možemo docrtati i liniju koja opisuje trend u podacima korišćenjem funkcije geom_smooth, koja napravi odredjenu aproksimaciju podataka (npr. linearni model, neki polinom i sl.) i nacrta je. Obogatimo grafik dodatno… ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Podrazumevano je da geom_smooth koristi metodu “loess” kao aproskimaciju koja nam daje nelinearnu ocenu trenda. Najjednostavnija ocena trenda je da provučemo pravu kroz podatke korišćenjem linearne regresije. To radimo davanjem argumenta method = &quot;lm&quot; funkciji geom_smooth. ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class, shape = drv), size = 3) + geom_smooth(method = &quot;lm&quot;) Dobili smo najbolju pravu kroz podatke. Kao bonus imamo i traku poverenja. Da se vratimo početnom grafiku, sada znate da protumačite kod… gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) Često je korisno kod ovakvih podataka koji imaju nagli rast pa onda skoro konstantan nivo promeniti skalu da gledamo logaritam od x ose, čime se trend pretvori u linearniji. To možemo lako da uradimo tako što dodamo i komponentu skaliranja x ose sa scale_x_continuous. Promenićemo i naslov za x osu sa funkcijom xlab. ggplot(data = gapminder2007) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) + scale_x_continuous(trans = &quot;log&quot;) + xlab(&quot;log(gdpPercap)&quot;) Sada se malo lakše vide neki podaci i više nisu u gužvi. 1.2.2 Linijski grafici Za crtanje vremenski uredjenih podataka, poput vremenskih serija, standardni grafici su linijski. To je prosto linija koja prikazuje kretanje neke promenljive kroz vreme. Za primer koristićemo skup podataka economics iz paketa ggplot2. Nacrtaćemo kretanje promenljive “psavert” kroz vreme ggplot(economics, aes(x = date, y = psavert)) + geom_line() Možemo i ovde dodati ocenu trenda ggplot(economics, aes(x = date, y = psavert)) + geom_line() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Napredniji primer Možemo i promeniti podeoke na x osi da budu meseci pored godina, kao i da budu prikazan tekst za svaku petu goinu na x osi sa funkcijom scale_x_date (“%b” u formatu oznacava mesec a “%Y” godinu, ovde vidite sve formate za datume). Nazive osa menjamo funkcijom labs. ggplot(economics, aes(x = date, y = psavert)) + geom_line(color = &quot;darkgreen&quot;) + geom_smooth() + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%b %Y&quot;) + labs(x = &quot;Mesec&quot;, y = &quot;Stopa stednje&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 1.2.3 Histogrami Gruba ocena raspodele uzorka se može vizuelizovati histogramima, gde brojimo koliko elemenata uzorka upada u odgovarajuće kategorije. U R-u ugradjena funkcija hist crta histograme, dok se u ggplot2 za to koristi geometrijski objekat geom_histogram. Pripremimo prvo podatke koje ćemo da koristimo za primer. Koristićemo podatke o temperaturi iz baze weather iz paketa nycflights13, pri čemu ćemo uzeti podatke samo za 26.02.2013. Takodje ćemo pretvoriti temperaturu iz farenhajta u celzijuse. library(nycflights13) # dodajemo kolonu u kojoj je temperatura po celzijusovoj skali weather$celsius &lt;- (weather$temp - 32) * 5 / 9 weather_today &lt;- weather[weather$month == 2 &amp; weather$day == 26, ] Sada da nacrtamo histogram library(ggplot2) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Obaveštava nas da je podrazumevano da se koristi 30 kategorija, pa je histogram dosta loš. Možemo promeniti broj kategorija ili širinu kategorija. Promenimo broj kategorija na 10. ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = 10) Sada nemamo problem sa brojem kategorija, ali histogram nije jasno vidljiv. Zato ćemo da uradimo najbitniji deo vizuelizacije - da ga obojimo. Stavićemo granice izmedju kolona bele boje i obojićemo kolone u plavo (sve moguće boje vidite pozivanjem colors()). ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = 10, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Ovo je već mnogo lepše.Uporedimo sa histogramom iz R-a. hist(weather_today$celsius) U R-u je podrazumevano da broj kategorija uzme kao \\(\\lceil \\log_2n + 1\\rceil\\), što se dobija pozivom nclass.Sturges funkcije. Odaberimo i mi broj kategorija po Sturges-ovoj formuli. bin_count &lt;- nclass.Sturges(weather_today$celsius) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(bins = bin_count, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Sada su histogrami slični ali opet nisu isti. To je zato što intervali u našem histogramu ne počinju od nule nego su malo pomereni ulevo, dok su u R-u u rasponu od 0 do 7. Gledanjem izvornog koda funkcije hist (pokretanjem hist.default u konzoli), vidimo da sledećim kodom R odredjuje granice intervala za kategorije pretty(range(x), n = breaks, min.n = 1). To ćemo i mi sada iskoristiti. bin_count &lt;- nclass.Sturges(weather_today$celsius) R_breaks &lt;- pretty(range(weather_today$celsius), n = bin_count, min.n = 1) ggplot(weather_today, aes(x = celsius)) + # dovoljna nam je samo x osa za histogram geom_histogram(breaks = R_breaks, color = &quot;white&quot;, fill = &quot;steelblue&quot;) Sada imamo isti histogram kao ugradjen u R! Cilj ovolike priče je da se vidi da je histogram vrlo osetljiv na odabir broja kategorija i tačne lokacije kategorija. Zato ggplot2 insistira na tome da se ručno podese sve željene vrednosti kod histograma i ne daje nikakve smislene podrazumevane vrednosti, da bi se korisnik ohrabrio da napravio histogram koji mu najlepše izgleda i koji najbolje oslikava priču koju želi da prenese podacima. 1.2.4 Crtanje više grafika odjednom Pre prelaska na boks plotove, pogledajmo ukratko kako možemo da pravimo više grafika odjednom, koji su rasporedjeni u mrežu. Za to koristimo funkciju facet_wrap. Nacrtaćemo histograme za različite mesece. ggplot(weather, aes(x = celsius)) + geom_histogram(color = &quot;white&quot;, fill = &quot;steelblue&quot;) + facet_wrap(~ month) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1 rows containing non-finite values (stat_bin). Odavde možemo da vidimo kako se razlikuju raspodele temperature po mesecima. Kao što je očekivano, raspodele u zimskim mesecima su pomerene ulevo u odnosu na letnje. 1.2.5 Boks plotovi U nekim slučajevima bolji način za poredjenje raspodela nam mogu omogućiti boks plotovi. Boks plot predstavlja grafički prikaz 5 sumarnih statistika - minimum, 1. kvartil, medijanu, 3. kvartil i maksimum. Te vrednosti dobijamo i pokretanjem funkcije summary na uzorku. summary(weather_today$celsius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 2.20 3.60 3.61 5.15 6.70 Boks plot se generiše funkcijom geom_boxplot. kada crtamo boks plot za jedan uzorak, dovoljno je dati samo y osu. ggplot(weather_today, aes(y = celsius)) + geom_boxplot() Boks plot se tumači ovako: Linija u sredini pravougaonika predstavlja medijanu. Gornja i donja ivica pravougaonika predstavljaju, redom, 3. i 1. kvartil. Linije koje idu izvan pravougaonika oslikavaju opseg uzorka, tj. idu od minimuma do maksimuma. Tačnije, obično se ne crtaju potpuno od minimuma do maksimuma, već su dužine \\(1.5 \\cdot IQR\\) (interkvartilno rastojanje - visina pravougaonika). Vrlo korisno svojstvo funkcije geom_boxplot je što može da koristi i x osu, koja mora biti kategorička, tj. faktor. Pogledajmo rezultat ako dodamo mesec, pretvoren u kategoričku promenljivu, kao x osu. ggplot(weather, aes(y = celsius, x = factor(month))) + geom_boxplot() ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). Dobili smo boks plotove za pojedinačne mesece! Sada možemo da uporedimo raspodele. Opet se vidi razlika u raspodeli temperature u letnjim mesecima. Jasnije se vidi i kako se temperatura menja kroz godinu. Tačke koje se vide van linija su neka vrsta autlajera, one iskaču van \\(1.5 \\cdot IQR\\) od ivica pravougaonika. Lepši opis strukture boks plotova može se naći npr. na https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51 1.2.6 Bar plotovi Bar plotovi nam služe za grafički prikaz kategoričkih promenljivih. Na njima se prikazuje koliko postoji podataka u bazi iz odgovarajuće kategorije. Razlikuju se od histograma po tome što ne svrstavaju podatke po kategorijama u zavisnosti od toga kom intervalu pripadaju njihove numeričke vrednosti, već prosto broje članove kategorija. Takodje, zbog prirode podataka, ne postoji uredjenje, pa nisu sa leve strane grafika “manje” vrednosti nego sa desne. U ggplot2 bar plotove crtamo sa funkcijom geom_bar. Takodje je dovoljno dati samo x osu. Probrojmo iz baze mpg broj podataka po klasi. ggplot(mpg, aes(x = class)) + geom_bar() Ovo je sivo i mora se obojiti ggplot(mpg, aes(x = class)) + geom_bar(fill = &quot;forestgreen&quot;, color = &quot;black&quot;) Nekad nećemo da prebrojimo elemente neke kategorije, već imamo u podacima za odredjenu kategoričku promenljivu dodeljenu neku vrednost. Na primer, u podacima gapminder imamo države i njihove populacije, pa možemo da nacrtamo populaciju po državama. To radimo funkcijom geom_col kojoj pored x ose dodamo i y osu sa odgovarajućim vrednostima. library(gapminder) # napravimo kratak spisak drzava koj cemo gledati countries &lt;- c(&quot;Bosnia and Herzegovina&quot;, &quot;Croatia&quot;, &quot;Montenegro&quot;, &quot;Serbia&quot;, &quot;Slovenia&quot;) gapminder2007 &lt;- gapminder[gapminder$year == 2007, ] gapminder_small &lt;- gapminder2007[gapminder2007$country %in% countries, ] ggplot(gapminder_small, aes(x = country, y = pop)) + geom_col(fill = &quot;forestgreen&quot;, color = &quot;black&quot;) Bar plotovi mogu biti i naslagani, da prikazuju više vrednosti za istu kategoriju odjednom. Lakše se vidi na primeru. Nacrtaćemo bar plot gde se vidi populacija za 1997., 2002. i 2007. godinu. library(gapminder) gapminder567 &lt;- gapminder[(gapminder$year %in% c(1997, 2002, 2007)) &amp; (gapminder$country %in% countries), ] ggplot(gapminder567, aes(x = country, y = pop)) + geom_col(color = &quot;black&quot;, mapping = aes(fill = factor(year))) Ovi grafici nisu laki za čitanje jer je teško uporediti veličine pravougaonika raznih boja. Korisnija alternativa se dobije kada se doda argument position = &quot;dodge&quot; ggplot(gapminder567, aes(x = country, y = pop)) + geom_col(color = &quot;black&quot;, mapping = aes(fill = factor(year)), position = &quot;dodge&quot;) Sada vidimo za sve godine kretanje populacije u državama i lakše je za poredjenje. Sve navedeno za geom_col može se odraditi za geom_bar ako se radi prebrojavanje odgovarajućih kategorija. Na primer, možemo prikazati broj letova iz paketa nycflights13 po kompanijama u zavisnosti od polazišta. ggplot(flights, aes(x = carrier, fill = origin)) + geom_bar(position = &quot;dodge&quot;) Ovime smo prešli sve osnovne grafike. "],
["115-galerija.html", "2 Galerija grafika Uvod 2.1 Ggplot2", " 2 Galerija grafika U nastavku je dat seminarski rad iz Statističkog softvera 1, pod naslovom “Paketi za grafičko predstavljanje”, čiji su autori koleginice Aida Al-Raghyfi i Nataša Martinović. Zahvaljujemo im na vrlo interesantnim primerima vizuelizacija mogućih paketom ggplot, kao i na prikazu drugih paketa za interaktivne grafike. Napomena. Radi brzine učitavanja, paketi plotly i highcharter su podeljeni u svoje stranice, koje su dostupne u sadržaju sa leve strane. Uvod Grafičko predstavljanje podataka je metod koji prikazuje vrednosti, izveštaje, upoređuje rezultate ili daje predviđanja o toku određenih situacija. To je vizuelni prikaz podataka kroz grafikone. U ovom radu, bavićemo se paketima: ggplot2, plotly i highcharter. 2.1 Ggplot2 Paket ggplot2 je jedan od najkorisnijih i najzastupljenijih paketa u R-u. Ima dosta različitu sintaksu od sintakse klasičnih grafika, i samim tim zahteva malo više učenja, ali najveća prednost ovog paketa je što se sa malo koda prave estetski bogati grafici. Paket ggplot2 se zasniva na takozvanoj “gramatici grafike”. Grafici se prave “sabiranjem”, odnosno dodajemo komponentu po komponentu na grafik. Glavni delovi koje grafik ima su: Podaci (data): Skup podataka koji se prikazuje Geometrijski objekat (geom_*): Tip geometrijskog objekta kojim se prikazuju podaci. Estetski parametri (aes()): Estetski atributi koji se mogu dodeliti geometrijskim objektima. Sada ćemo proći kroz par jednostavnih primera library(ggplot2) data(&quot;midwest&quot;, package = &quot;ggplot2&quot;) midwest &lt;- read.csv(&quot;http://goo.gl/G1K41K&quot;) #Za primer koristićemo skup podataka midwest iz paketa ggplot2. Ovo je skup podataka populacije svih okruga od 5 država srednjeg zapada SAD-a. g&lt;-ggplot(midwest, aes(x=area, y=poptotal)) + geom_point(col=&quot;steelblue&quot;, size=3) + #funkcija geom_point tačakama predstavlja svaki okrug iz naše tabele geom_smooth(method=&quot;lm&quot;, col=&quot;firebrick&quot;) #funkcija geom_smooth pravi određenu aproksimaciju podataka, u ovom slučaju je to linearni model, ali može biti i nelinearni model, što ćemo videti kasnije g g + xlim(c(0, 0.1)) + ylim(c(0, 1000000)) #Pošto se tačke većinom nalaze na donjoj polovini, funkcijom xlim/ylim možemo da posmatramo grafik u granicama koje mi odredimo, i na taj način obrišemo tačke van tih granica ## Warning: Removed 5 rows containing non-finite values (stat_smooth). ## Warning: Removed 5 rows containing missing values (geom_point). g1&lt;-g+coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) #Ili funkcijom coord_cartesian() da zumiramo grafik u delu koji nama odgovara g1 + ggtitle(&quot;Area Vs Population&quot;, subtitle=&quot;From midwest dataset&quot;) + xlab(&quot;Area&quot;) + ylab(&quot;Population&quot;) #Funkcija za stavljanje naslova i podnaslova gg &lt;- ggplot(midwest, aes(x=area, y=poptotal)) + geom_point(aes(col=state,size=popdensity)) + #Stavljamo da svaki okrug ima svoju boju u zavisnoti od toga u kojoj državi se nalazi i veličinu u zavisnosti od gustine naseljenosti geom_smooth(method=&quot;loess&quot;, col=&quot;firebrick&quot;, size=2) + #ovde možemo videti nelinearni metod aproksimacije podataka coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) + #ograničavamo gornje i donje vrednosti koordinatnih osa labs(title=&quot;Area Vs Population&quot;, subtitle=&quot;From midwest dataset&quot;, y=&quot;Population&quot;, x=&quot;Area&quot;, caption=&quot;Midwest Demographics&quot;) plot(gg) #Sada ćemo da izdvojimo i zaokružimo okruge koji imaju između 350000 i 500000 stanovnika i sa površinom izmedju 0.01 i 0.1 library(ggalt) ## Registered S3 methods overwritten by &#39;ggalt&#39;: ## method from ## grid.draw.absoluteGrob ggplot2 ## grobHeight.absoluteGrob ggplot2 ## grobWidth.absoluteGrob ggplot2 ## grobX.absoluteGrob ggplot2 ## grobY.absoluteGrob ggplot2 midwest_select &lt;- midwest[midwest$poptotal &gt; 350000 &amp; midwest$poptotal &lt;= 500000 &amp; midwest$area &gt; 0.01 &amp; midwest$area &lt; 0.1, ] ggplot(midwest, aes(x=area, y=poptotal)) + geom_point(aes(col=state, size=popdensity)) + geom_smooth(method=&quot;loess&quot;, se=F) + xlim(c(0, 0.1)) + ylim(c(0, 500000)) + geom_encircle(aes(x=area, y=poptotal), data=midwest_select, color=&quot;red&quot;, size=2, expand=0.08) + labs(subtitle=&quot;Area Vs Population&quot;, y=&quot;Population&quot;, x=&quot;Area&quot;, title=&quot;Scatterplot + Encircle&quot;, caption=&quot;Source: midwest&quot;) ## Warning: Removed 15 rows containing non-finite values (stat_smooth). ## Warning: Removed 15 rows containing missing values (geom_point). #Sada posmatramo skup podataka mpg iz paketa ggplot2, odnosno uzeti su podaci iz Motor Trend US magazina, iz 1974. godine, koji obuhvataju potrošnju goriva i 10 aspekata dizajna automobila i performanse za 32 automobila. data(mpg, package=&quot;ggplot2&quot;) mpg &lt;- read.csv(&quot;http://goo.gl/uEeRGu&quot;) g &lt;- ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=FALSE) + theme_bw() mpg1&lt;-g + facet_wrap( ~ class, nrow=3) + labs(title=&quot;hwy vs displ&quot;, caption = &quot;Source: mpg&quot;, subtitle=&quot;Ggplot2 - Faceting - Multiple plots in one figure&quot;) #Funkcija facet_wrap() omogućava predstavljanje jednog grafika pomoću više manjih grafika za kategorije koje mi želimo #Koristeći nrow biramo broj vrsta u kojima će se nalaziti manji grafici mpg1 mpg2&lt;-g + facet_wrap( ~ class, scales = &quot;free&quot;) + labs(title=&quot;hwy vs displ&quot;, caption = &quot;Source: mpg&quot;, subtitle=&quot;Ggplot2 - Faceting - Multiple plots in one figure with free scales&quot;) #Dok sa scales=&quot;free&quot; program sam odabere mpg2 #U ovom konkretnom primeru, upoređujući dobijene manje grafike zaključujemo da sportski automobili koji imaju velike motore, a malu masu troše manje nego pickup i minivan #Sada prikazujemo estetske promene, kao što su: menjanje boje pozadine, menjanje debljine i boje svih unutrašnjih linija, kao i ivica i x/y-osa g &lt;- ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=FALSE) + theme_bw() g + theme(panel.background = element_rect(fill = &#39;khaki&#39;), panel.grid.major = element_line(colour = &quot;burlywood&quot;, size=1.5), panel.grid.minor = element_line(colour = &quot;tomato&quot;, size=.25, linetype = &quot;dashed&quot;), panel.border = element_blank(), axis.line.x = element_line(colour = &quot;darkorange&quot;, size=1.5, lineend = &quot;butt&quot;), axis.line.y = element_line(colour = &quot;darkorange&quot;, size=1.5)) + labs(title=&quot;Modified Background&quot;, subtitle=&quot;How to Change Major and Minor grid, Axis Lines, No Border&quot;) #Po želji se mogu menjati i margine grafika g + theme(plot.background=element_rect(fill=&quot;salmon&quot;), plot.margin = unit(c(2, 2, 1, 1), &quot;cm&quot;)) + # gore,desno,dole,levo labs(title=&quot;Modified Background&quot;, subtitle=&quot;How to Change Plot Margin&quot;) Sada ćemo prikazati još neke tipove geometrijskih objekata kojim se prikazuju podaci. 2.1.1 Linijski grafici Za crtanje vremenski uređenih podataka, poput vremenskih serija, standardni grafici su linijski. To je prosto linija koja prikazuje kretanje neke promenljive kroz vreme. #Za primer koristićemo skup podataka economics iz paketa ggplot2. data(&quot;economics&quot;, package = &quot;ggplot2&quot;) ggplot(economics, aes(x = date, y = psavert)) + geom_line(color = &quot;darkgreen&quot;) + geom_smooth() + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%b %Y&quot;) + labs(x = &quot;Mesec&quot;, y = &quot;Stopa stednje&quot;) #Funkcijom scale_x_date možemo da odaberemo na koliko godina ćemo da pratimo promene, u ovom konkretnom slučaju smo stavili 5 (“%b” u formatu označava mesec a “%Y” godinu, pa možemo da menjamo i redosled) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 2.1.2 Stacked area chart Sličan linijskom grafiku, s tim da je oblast ispod linija obojen. Koristimo ga kada želimo da vidimo kako se kvantitet promenio kroz vreme, kada prikazujemo udeo individualnih komponenata. Treba primetiti jednu bitnu stvar, po default-u svaka geom_area() počinje od y-ose(što je obično 0), ali ako želimo da prikažemo udeo individualnih komponenata, potrebno je da svaka geom_area() bude naslagana jedna na drugu. S toga ćemo u sledećem primeru staviti y=stopastednje+srednjetrajanjenezaposlenosti library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date theme_set(theme_bw()) df &lt;- economics[, c(&quot;date&quot;, &quot;psavert&quot;, &quot;uempmed&quot;)] #pravimo kolonu sa potrebnim vrednostima df &lt;- df[lubridate::year(df$date) %in% c(1967:1981), ] brks &lt;- df$date[seq(1, length(df$date), 12)] #podele za x-osu, na svakih 12 meseci lbls &lt;- lubridate::year(brks) #oznake koje će biti na x-osi ggplot(df, aes(x=date)) + geom_area(aes(y=psavert+uempmed, fill=&quot;psavert&quot;)) + geom_area(aes(y=uempmed, fill=&quot;uempmed&quot;)) + labs(title=&quot;Area Chart of Returns Percentage&quot;, subtitle=&quot;From Wide Data format&quot;, caption=&quot;Source: Economics&quot;, y=&quot;Returns %&quot;) + scale_x_date(labels = lbls, breaks = brks) + scale_fill_manual(name=&quot;&quot;, values = c(&quot;psavert&quot;=&quot;#00ba38&quot;, &quot;uempmed&quot;=&quot;#f8766d&quot;)) # boja linija 2.1.3 Sezonski grafik Ako radimo sa vremenskim serijama klase ts ili xts, možemo da vidimo sezonske fluktuacije pomoću sezonskih grafika koristeći forecast::ggseasonplot. #install.packages(&quot;forecast&quot;) library(ggplot2) library(forecast) ## Registered S3 method overwritten by &#39;xts&#39;: ## method from ## as.zoo.xts zoo ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo ## Registered S3 methods overwritten by &#39;forecast&#39;: ## method from ## fitted.fracdiff fracdiff ## residuals.fracdiff fracdiff theme_set(theme_classic()) #Uzimamo podatke o sezonskim promenenama broja putnika na međunarodnim letovima, kao i o sezonskim promenama vazdušne temperature u Nottingham Castle-u nottem_small &lt;- window(nottem, start=c(1920, 1), end=c(1925, 12)) # uzimamo manji vremenski period #Sezonske promene broja putnika na međunarodnim letovima ggseasonplot(AirPassengers) + labs(title=&quot;Seasonal plot: International Airline Passengers&quot;) #Sezonske promene vazdušne temperature u Nottingham Castle-u ggseasonplot(nottem_small) + labs(title=&quot;Seasonal plot: Air temperatures at Nottingham Castle&quot;) 2.1.4 Bar plotovi Bar plotovi nam služe za grafički prikaz kategoričkih promenljivih. Na njima se prikazuje koliko postoji podataka u bazi iz odgovarajuće kategorije. #Prebrojimo iz baze mpg broj automobila po klasi ggplot(mpg, aes(x = class)) + geom_bar(fill = &quot;forestgreen&quot;, color = &quot;black&quot;) #Bar plotovi mogu biti i naslagani, da prikazuju više vrednosti za istu kategoriju odjednom. #Nacrtaćemo bar plot gde se vidi populacija za 1997., 2002. i 2007. godinu izabranih zemalja. #position = &quot;dodge&quot; nam pomaže da lakše čitamo vrednosti sa grafika, tako što ih stavlja jednu do druge library(gapminder) # napravimo kratak spisak država koje ćemo gledati i upoređivati populacije tokom određenih godina countries &lt;- c( &quot;Turkey&quot;, &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Belgium&quot;) gm &lt;- gapminder[(gapminder$year %in% c(1997, 2002, 2007)) &amp; (gapminder$country %in% countries), ] ggplot(gm, aes(x = country, y = pop)) + geom_col(color = &quot;black&quot;, mapping = aes(fill = factor(year)), position = &quot;dodge&quot;) 2.1.5 Lollipop grafik U suštini sadrži iste informacije kao bar plot, s tim što ih redukuje u tanke linije, pa samim tim izgledaju lepše i modernije. library(ggplot2) theme_set(theme_bw()) ggplot(gm, aes(x = country, y = pop,label=year)) + geom_point(size=3) + geom_segment(aes(x=country, xend=country, y=0, yend=pop)) + labs(title=&quot;Lollipop Chart&quot; ) + theme(axis.text.x = element_text(angle=65, vjust=0.6)) + #udaljenost naziva država od linije x-ose geom_text(nudge_x = 0.2 ) #udaljenost godina od tačkica 2.1.6 Dumbbell plot Koristimo ga ako želimo da predstavimo rast i opadanje između dve tačke u vremenu i poredimo udaljenost između dve kategorije #Posmatramo bazu podataka health koja nam daje procente iz 2013. i 2014. za 26 gradova u SAD-u. ##devtools::install_github(&quot;hrbrmstr/ggalt&quot;) library(ggplot2) library(ggalt) theme_set(theme_classic()) health &lt;- read.csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/health.csv&quot;) health$Area &lt;- factor(health$Area, levels=as.character(health$Area)) #za pravilno uređenje ovih tegića ggplot(health, aes(x=pct_2013, xend=pct_2014, y=Area, group=Area)) + geom_dumbbell( color=&quot;blue&quot;, size=0.75, ) + labs(x=NULL, y=NULL, title=&quot;Dumbbell Chart&quot;, subtitle=&quot;Pct Change: 2013 vs 2014&quot;, caption=&quot;Source: https://github.com/hrbrmstr/ggalt&quot;) + theme(plot.title = element_text(hjust=0.5, face=&quot;bold&quot;), plot.background=element_rect(fill=&quot;#f7f7f7&quot;), panel.background=element_rect(fill=&quot;#f7f7f7&quot;), panel.grid.minor=element_blank(), panel.grid.major.y=element_blank(), panel.grid.major.x=element_line(), axis.ticks=element_blank(), legend.position=&quot;top&quot;, panel.border=element_blank()) 2.1.7 Histogram Gruba ocena raspodele uzorka se može vizuelizovati histogramima, gde brojimo koliko elemenata uzorka upada u odgovarajuće kategorije. Koristeći histogram, možemo da kontrolišemo broj pravougaonika, takođe možemo odabrati koliki interval pokriva svaki pravougaonik. library(ggplot2) theme_set(theme_classic()) ##Ponovo posmatramo automobile, i posmatramo broj vozila određene klase po zapremini motora g &lt;- ggplot(mpg, aes(displ)) + scale_fill_brewer(palette = &quot;Spectral&quot;) g + geom_histogram(aes(fill=class), binwidth = .1, col=&quot;black&quot;, size=.1) + labs(title=&quot;Histogram sa automatskim brojem pravougaonika&quot;, subtitle=&quot;Engine Displacement across Vehicle Classes&quot;) g + geom_histogram(aes(fill=class), bins=5, col=&quot;black&quot;, size=.1) + labs(title=&quot;Histogram sa fiksiranim brojem pravougaonika&quot;, subtitle=&quot;Engine Displacement across Vehicle Classes&quot;) 2.1.8 Grafik gustine Grafik gustine predstavlja raspodelu podataka u kontinuiranom intervalu ili vremenskom periodu. To je zapravo verzija histograma koja glatko iscrtava vrednosti kako bi se izbegli grubi prelazi. library(ggplot2) theme_set(theme_classic()) #I dalje posmatramo mpg bazu podataka i pravimo grafik gustine gradske kilometraže u odnosu na broj cilindara #Podešavamo alfa transparentnost i bojimo gustine u odnosu na broj cilindara g &lt;- ggplot(mpg, aes(cty)) g + geom_density(aes(fill=factor(cyl)), alpha=0.8) + labs(title=&quot;Density plot&quot;, subtitle=&quot;City Mileage Grouped by Number of cylinders&quot;, caption=&quot;Source: mpg&quot;, x=&quot;City Mileage&quot;, fill=&quot;# Cylinders&quot;) 2.1.9 Boks plot Boks plot predstavlja grafički prikaz 5 sumarnih statistika - minimum, 1. kvartil, medijanu, 3. kvartil i maksimum. library(ggplot2) theme_set(theme_classic()) #Stavljanjem varwidth=T podešavamo da debljina boksova bude proporcionalna broju vrednosti koje sadrži #Posmatramo gradsku kilometražu grupisanu po klasi vozila g &lt;- ggplot(mpg, aes(class, cty)) g + geom_boxplot(varwidth=T, fill=&quot;plum&quot;) + labs(title=&quot;Box plot&quot;, subtitle=&quot;City Mileage grouped by Class of vehicle&quot;, caption=&quot;Source: mpg&quot;, x=&quot;Class of Vehicle&quot;, y=&quot;City Mileage&quot;) 2.1.10 Violinski grafik Sličan je box plotu, ali pokazuje gustinu unutar grupa. Ne prikazuje toliko informacija kao box plot. library(ggplot2) theme_set(theme_bw()) g &lt;- ggplot(mpg, aes(class, cty)) g + geom_violin() + labs(title=&quot;Violin plot&quot;, subtitle=&quot;City Mileage vs Class of vehicle&quot;, caption=&quot;Source: mpg&quot;, x=&quot;Class of Vehicle&quot;, y=&quot;City Mileage&quot;) 2.1.11 Populaciona piramida Predstavlja unikatan način predstavljanja koliki procenat populacije spada u određenu kategoriju. Piramida ispod je odličan primer toga koliko korisnika se zadrži na svakoj fazi e-mail marketinške kampanje. #install.packages(&quot;ggthemes&quot;) library(ggplot2) library(ggthemes) #baza podataka koju posmatramo email_campaign_funnel &lt;- read.csv(&quot;https://raw.githubusercontent.com/selva86/datasets/master/email_campaign_funnel.csv&quot;) #podele koje će se nalaziti na x-osi i oznake brks &lt;- seq(-15000000, 15000000, 5000000) lbls = paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), &quot;m&quot;) ggplot(email_campaign_funnel, aes(x = Stage, y = Users, fill = Gender)) + #x-osa sadrži faze, dok y-osa sadrži broj korisnika, i bojimo naše pravougaonike u odnosu na pol korisnika geom_bar(stat = &quot;identity&quot;, width = .6) + # crtanje pravougaonika scale_y_continuous(breaks = brks, # podele labels = lbls) + # oznake coord_flip() + # zamena osa labs(title=&quot;Email Campaign Funnel&quot;) + theme_tufte() + # Tufte theme iz ggfortify theme(plot.title = element_text(hjust = .5)) + #podešavanje i centriranje naslova scale_fill_brewer(palette = &quot;Dark2&quot;) #biramo paletu boja za naše pravougaonike 2.1.12 Pitica Pitica (ili kružni dijagram) je kružni statistički grafik koji je podeljen na parčiće. Površina svakog parčića je proporcionalna količini koju predstavlja. #Sada ćemo piticom da predstavimo odnos broja vozila svih ponudjenih klasa pie &lt;- ggplot(mpg, aes(x = &quot;&quot;, fill = factor(class))) + geom_bar(width = 1) + theme(axis.line = element_blank(), #izbacujemo x-osu i y-osu plot.title = element_text(hjust=0.5)) + #podešavamo i centriramo naslov labs(fill=&quot;class&quot;, x=NULL, y=NULL, title=&quot;Pie Chart of class&quot;, caption=&quot;Source: mpg&quot;) pie + coord_polar(theta = &quot;y&quot;) 2.1.13 Hijerarhijski dendrogram Pomoću njih grupišemo objekte, koji su slični u nekom smislu, u grupe koje se zovu klasteri i zatim pravimo hijerarhijsku vezu. #U narednom primeru ćemo hijerarhijski predstaviti broj uhapšenih kriminalaca na 100000 ljudi u svim državama SAD-a. #install.packages(&quot;ggdendro&quot;) library(ggplot2) library(ggdendro) theme_set(theme_bw()) hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) #hijerarhijski klastering, metoda &quot;average&quot; ggdendrogram(hc, rotate = T, size = 2) "],
["1152-plotly.html", "2.2 Plotly", " 2.2 Plotly Plotly je drugi paket koji ćemo posmatrati. Početna inspiracija za ovaj paket je bila podrška plotly.js tipova grafika koje ggplot2 ne podržava. Plotly ima bogate karakteristike, kao i dosta pristupačnih grafika. Poseduje web-based toolbox koristan za vizualizaciju. I takođe ima sposobnost da ggplot2 grafike učini interaktivnim. 2.2.1 Scatterplot Scatterplot je koristan za vizualizaciju povezanosti dve kvantitativne promenljive, problem se javlja ako dođe do preklapanja, i to možemo rešiti na par načina. #Posmatramo na x-osi gradsku miljažu, dok na y-osi posmatramo miljažu auto-puta library(plotly) ## ## Attaching package: &#39;plotly&#39; ## The following object is masked from &#39;package:ggplot2&#39;: ## ## last_plot ## The following object is masked from &#39;package:stats&#39;: ## ## filter ## The following object is masked from &#39;package:graphics&#39;: ## ## layout subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), #po default-u plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;), #alfa transparentnost plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(1), name = &quot;hollow&quot;) #uzimamo jedan simbol, i stavićemo da bude šupalj ) ## No trace type specified: ## Based on info supplied, a &#39;scatter&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#scatter ## No scatter mode specifed: ## Setting the mode to markers ## Read more about this attribute -&gt; https://plot.ly/r/reference/#scatter-mode #Sada ćemo da vidimo na koji način možemo da koristimo simbole subplot( plot_ly(x = 1:6, y = 1:6, symbol = I(1:6), name = &quot;pch&quot;), plot_ly(mpg, x = ~cty, y = ~hwy, symbol = ~cyl, symbols = 1:3,name = &quot;cyl&quot;)) #ponovo posmatramo na x-osi gradsku miljažu, dok na y-osi posmatramo miljažu auto-puta, i uzimamo različite simbole u odnosu na broj cilindara ## No trace type specified: ## Based on info supplied, a &#39;scatter&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#scatter ## No scatter mode specifed: ## Setting the mode to markers ## Read more about this attribute -&gt; https://plot.ly/r/reference/#scatter-mode ## No trace type specified: ## Based on info supplied, a &#39;scatter&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#scatter ## No scatter mode specifed: ## Setting the mode to markers ## Read more about this attribute -&gt; https://plot.ly/r/reference/#scatter-mode #Kada mapiramo numeričku promenljivu u simbol, napravi se samo jedan trag, pa se ne generiše legenda. Međutim ako želimo jedan trag po simbolu, moramo da se postaramo da je promenljiva koju mapiramo faktor, kao u narednom primeru: p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) #Argument color ima slične osobine kao simbol, odnosno, ako je numerička vrednost u pitanju, color ima jedan trag, ali se generiše kao colorbar kako bi se razlikovale vrednosti promenljivih. Viridis je po default-u namešten colorbar. Takođe, ako je u pitanju faktor, onda color za svaku vrednost napravi trag. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;), add_markers(p, color = ~factor(cyl)) ) #Postoji više načina kako da promenimo boje koje su nameštene po default-u col1 &lt;- c(&quot;#132B43&quot;, &quot;#56B1F7&quot;) col2 &lt;- viridisLite::inferno(10) col3 &lt;- colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;)) subplot( add_markers(p, color = ~cyl, colors = col1) %&gt;% colorbar(title = &quot;ggplot2 default&quot;), add_markers(p, color = ~cyl, colors = col2) %&gt;% colorbar(title = &quot;Inferno&quot;), add_markers(p, color = ~cyl, colors = col3) %&gt;% colorbar(title = &quot;colorRamp&quot;) ) %&gt;% hide_legend() #Argument size kontroliše maksimum i minimum veličine kružića (u pikselima) subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 200), name = &quot;custom&quot;) ) ## Warning: `line.width` does not currently support multiple values. ## Warning: `line.width` does not currently support multiple values. Sada ćemo proći kroz još neke tipove geometrijskih objekata kojim se prikazuju podaci. 2.2.2 Histogram i Bar plot Glavna razlika ove dve funkcije je što bar plot zahteva i visinu (odnosno i x i y-osu), dok za histogram treba samo jedna promenljiva. U primeru ispod poredimo algoritam naslaganja po default-u u plotly.js sa nekoliko različitih algoritama dostupnih u R-u preko hist() funkcije. #Hist() funkcija nam pruža priliku da spomenemo tri poznata algoritma po nazivu (Sturges 1926); (Freedman and Diaconis 1981); (Scott 1979). #Price_hist() služi da zadrži rezultate naslaganja, kao i njihovo mapiranje pomoću funkcije add_bars(). #Posmatramo bazu podataka Diamonds iz paketa plotly i histogramom predstavljamo cenu dijamanata. p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(&quot;FD&quot;), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) #stavljamo grafike jedne ispod drugih, kako b delili x-osu #U sledećem primeru gledamo dva načina kreiranja osnovnog bar plota, vizuelno su rezultati isti, ali pokazaćemo razliku u implementiranju. #add_histogram() funkcija šalje sve posmatrane vrednosti browser-u i dozvoljava plotly.js-u da obavlja naslaganje. Što se tiče drugog načina, potrebno je više ljudskog truda da se to izvede, ali je prednost što se šalje manje podataka i zahteva manje računanja od strane web browser-a. #Pravimo bar plotove u odnosu na kvalitet po rezu p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% #prebrojava sve vrednosti u zavisnosti od reza plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() 2.2.3 Box plot Kao što smo već rekli, box plot predstavlja grafički prikaz 5 sumarnih statistika. Add_boxplot() funkcija zahteva jednu promenljivu i garantuje da box plotovi budu korektno orijentisani, bez obzira na to da li je promenljiva pozicionirana na x ili y-osi. #U sledećem primeru posmatramo sveukupne cene i cene po rezu. Stavićemo sve vrednosti na isti grafik, deleći njihovu y-osu. p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() #Ako želimo da koristimo više promenljivih, preporučuje se mapiranje njihove interakcije na diskretnu osu i bojenje grupisanih vrednosti. #U narednom primeru smo to uradili sa cenama dijamanata po rezu i bistrini. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;)) 2.2.4 Pravougaono naslaganje Postoje dve funkcije za predstavljanje pravougaonog naslaganja: add_heatmap() i add_histogram2d(). Add_heatmap() funkcija je 2D analogna funkciji add_bars(), a funkcija add_histogram2d() je 2D analogna funkciji add_histogram(). #U ovom primeru posmatramo odnos cena i broja karata i poredimo tri različite funkcije add_histogram2d(): ##1. Naslaganje po default-u ##2. Naslaganje po default-u sa funkcijom zsmooth koja služi za efektivni rast broja pravougaoničića. ##3. Određivanje broja pravougaonika p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) ##Animacije options(warn=-1) #Pokazaćemo evoluciju odnosa između bruto društvenog proizvoda i očekivanog životnog veka od 1952 do 2007 godine. data(gapminder, package = &quot;gapminder&quot;) gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + geom_point(aes(size = pop, frame = year, ids = country)) + #za frame stavljamo year jer su podaci zabeleženi na godišnjoj bazi, dok je za ids postavljeno country, što omogućava glatki prelaz iz godine u godinu scale_x_log10() ggplotly(gg) #sve dok postoji frame, animacija se realizuje sa play/pause dugmićima i slider komponentom za kontrolisanje animacije. #Ove komponente se mogu ukloniti ili preurediti funkcijama animation_button() i animation_slider(). #Razne animacione opcije, kao što je vreme između kadrova, trajanje prelaza i olakšanje prelaza menjaju se preko funkcije animation_opts(). # U sledećem primeru prikazani su isti podaci, ali je udvostručena količina vremena između kadrova, stavlja animacionu dugmad bliže slideru, modifikuje default currentvalue.prefix podešavanja slidera. base &lt;- gapminder %&gt;% plot_ly(x = ~gdpPercap, y = ~lifeExp, size = ~pop, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% #lebdeći tekst, da se prikazuju države kod kružića layout(xaxis = list(type = &quot;log&quot;)) base %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, easing = &quot;elastic&quot;) %&gt;% animation_button( x = 1, xanchor = &quot;right&quot;, y = 0, yanchor = &quot;bottom&quot; ) %&gt;% animation_slider( currentvalue = list(prefix = &quot;YEAR &quot;, font = list(color=&quot;red&quot;)) ) # I frame i ids služe da animiraju određene delove grafika. Može da se obezbedi pozadina koja prikazuje svaki mogući okvir (koji nije animiran) i preklapa animirane kadrove na tu pozadinu. Na narednoj slici prikazane su iste informacije kao na prethodnoj, ali slojevi animiranih okvira se pojavljuju na pozadini svih okvira. base %&gt;% add_markers(color = ~continent, alpha = 0.2, showlegend = F) %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, redraw = FALSE) options(warn=0) "],
["1153-highcharter.html", "2.3 Highcharter", " 2.3 Highcharter Highcharter je R omotač za Highcharts JavaScript bibiloteku. Paket koristi sintaksu nalik na ggplot2, uključujući opcije za rukovanje dugim i opširnim podacima. Postoje funkcije čije ponašanje je slično funkcijama ggplot2 paketa kao, što je hchart, koja radi kao ggplot, zatim hc_add_series radi kao geom_S i hcaes radi kao aes. Glavna razlika u geom_ funkcijama ggplot2-a i hc_add_series je u tome što moramo dodati podatke i estetiku eksplicitno u svakoj funkciji, dok u ggplot2 možemo ubaciti podatke i estetiku u sloj, a zatim dodati još geom_ funkcija koje mogu raditi na istim podacima i estetici. Sada ćemo videti jedan jednostavni primer. #install.packages(&quot;highcharter&quot;) library(highcharter) ## Highcharts (www.highcharts.com) is a Highsoft software product which is ## not free for commercial and Governmental use ## ## Attaching package: &#39;highcharter&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## weather ## The following object is masked from &#39;package:nycflights13&#39;: ## ## weather library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union ##Posmatraćemo podatke o pokemonima koji se nalaze u pakovanju highcharter ##Prvo ćemo predstaviti preko bar chart-a ukupan broj iz svake kategorije type1, za to nam služi objekat type, koji smo podesili na &quot;bar&quot; pokemon%&gt;% count(type_1)%&gt;% arrange(n)%&gt;% hchart(type = &quot;bar&quot;, hcaes(x = type_1, y = n)) ##Takođe možemo istu stvar predstaviti i pomoću kolona pokemon%&gt;% count(type_1)%&gt;% arrange(n)%&gt;% hchart(type = &quot;column&quot;, hcaes(x = type_1, y = n)) Sada ćemo iste podatke predstaviti preko treemap-e. pokemon%&gt;% count(type_1)%&gt;% arrange(n)%&gt;% hchart(type = &quot;treemap&quot;, hcaes(x = type_1, value = n, color = n)) U narednom kodu predstavićemo procentualni odnos populacije svih kontinenata tokom godina highchart() %&gt;% hc_chart(type = &quot;area&quot;) %&gt;% #tip highcharter-a hc_title(text = &quot;Historic and Estimated Worldwide Population Distribution by Region&quot;) %&gt;% #naslov hc_subtitle(text = &quot;Source: Wikipedia.org&quot;) %&gt;% #podnaslov hc_xAxis(categories = c(&quot;1750&quot;, &quot;1800&quot;, &quot;1850&quot;, &quot;1900&quot;, &quot;1950&quot;, &quot;1999&quot;, &quot;2050&quot;), #x-osa podeljena po godinama tickmarkPlacement = &quot;on&quot;)%&gt;% #oznake tačkicama kod izlomljenih linija hc_yAxis(title = list(text = &quot;Percent&quot;)) %&gt;% hc_tooltip(pointFormat = &quot;&lt;span style=\\&quot;color:{series.color}\\&quot;&gt;{series.name}&lt;/span&gt;: &lt;b&gt;{point.percentage:.1f}%&lt;/b&gt; ({point.y:,.0f} millions)&lt;br/&gt;&quot;, shared = TRUE) %&gt;% #tooltip koji prikazuje procenat i broj stanovnika za onu godinu na koju smo pokazali hc_plotOptions(area = list( stacking = &quot;percent&quot;, lineColor = &quot;#ffffff&quot;, lineWidth = 1, marker = list( lineWidth = 1, lineColor = &quot;#ffffff&quot; )) ) %&gt;% hc_add_series(name = &quot;Asia&quot;, data = c(502, 635, 809, 947, 1402, 3634, 5268)) %&gt;% hc_add_series(name = &quot;Africa&quot;, data = c(106, 107, 111, 133, 221, 767, 1766)) %&gt;% hc_add_series(name = &quot;Europe&quot;, data = c(163, 203, 276, 408, 547, 729, 628)) %&gt;% hc_add_series(name = &quot;America&quot;, data = c(18, 31, 54, 156, 339, 818, 1201)) %&gt;% hc_add_series(name = &quot;Oceania&quot;, data = c(2, 2, 2, 6, 13, 30, 46)) #odnos u procentima pri svakoj izabranoj godini Sada ponovo posmatramo bazu podataka mpg i pravimo sledeći grafik data(mpg, package = &quot;ggplot2&quot;) mpgg &lt;- mpg %&gt;% filter(class %in% c(&quot;suv&quot;, &quot;compact&quot;, &quot;midsize&quot;)) %&gt;% group_by(class, manufacturer) %&gt;% summarize(count = n()) #izdvojili smo tri klase i sabrali ukupan broj automobila po proizvođaču u svakoj klasi categories_grouped &lt;- mpgg %&gt;% group_by(name = class) %&gt;% #grupišemo u tri klase koje smo gore izdvojili do(categories = .$manufacturer) %&gt;% list_parse() #navodimo proizvođače za svaku od klasa i funkcijom list_parse() raščlanimo listu highchart() %&gt;% hc_xAxis(categories = categories_grouped) %&gt;% hc_add_series(data = mpgg, type = &quot;bar&quot;, hcaes(y = count, color = manufacturer), showInLegend = FALSE) Sada ćemo pomoću treemap-e da podelimo pokemone prvo po tipu 1, zatim svaku tu kategoriju da podelimo na podkategorije prema tipu 2, pri čemu postoje pokemoni koji nemaju tip 2 tm &lt;- pokemon %&gt;% mutate(type_2 = ifelse(is.na(type_2), paste(&quot;only&quot;, type_1), type_2), type_1 = type_1) %&gt;% #za sve pokemone koji nemaju tip 2, stavićemo ih u kategoriju &quot;only&quot; tip 1 group_by(type_1, type_2) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% treemap::treemap(index = c(&quot;type_1&quot;, &quot;type_2&quot;), vSize = &quot;n&quot;, vColor = &quot;type_1&quot;) #boja i veličina pravougaonika je podešena u odnosu na tip1 kom pripadaju i broju pokemona koja pripada tom tipu Sada pomoću baze podataka weather predstavljamo minimalnu, maksimalnu i srednju temperaturu svakog dana 2014-e godine. data(&quot;weather&quot;) x &lt;- c(&quot;Min&quot;, &quot;Mean&quot;, &quot;Max&quot;) y &lt;- sprintf(&quot;{point.%s}&quot;, c(&quot;min_temperaturec&quot;, &quot;mean_temperaturec&quot;, &quot;max_temperaturec&quot;)) tltip &lt;- tooltip_table(x, y) #U tooltip-u štampamo vrednosti minimalne, srednje i maksimalne temperature hchart(weather, type = &quot;columnrange&quot;, hcaes(x = date, low = min_temperaturec, high = max_temperaturec, color = mean_temperaturec)) %&gt;% hc_chart(polar = T) %&gt;% #polarne koordinate hc_yAxis( max = 30, min = -10, labels = list(format = &quot;{value} C&quot;), showFirstLabel = FALSE) %&gt;% #podešavamo podatke y-ose, maksimum, minimum, odnosno u ovom slučaju, centar je u -10, pa samim tim poluprečnik je 40. hc_xAxis( title = list(text = &quot;&quot;), gridLineWidth = 0.5, labels = list(format = &quot;{value: %b}&quot;)) %&gt;% hc_tooltip(useHTML = TRUE, pointFormat = tltip, headerFormat = as.character(tags$small(&quot;{point.x:%d %B, %Y}&quot;))) "],
["12-dplyr.html", "3 Rad sa podacima 3.1 Dataframe 3.2 Obrada podataka - dplyr paket 3.3 Učitavanje eksternih podataka 3.4 Osnovne funkcije paketa dplyr", " 3 Rad sa podacima U ovom poglavlju ćemo se upoznati sa osnovnim metodama rada sa podacima, prvenstveno kroz paket dplyr, koji je jedan od najkorišćenijih paketa u R-u. Pre upoznavanja sa tim paketom, osnvrnućemo se na osnovnu strukturu podataka u R-u, dataframe, koja se koristi za rad sa tabelarnim podacima. 3.1 Dataframe Dataframe je najčešći način čuvanja podataka u R-u i vrlo je pogodan za rad i analizu. Služi za prikaz tabelarnih podataka, pa liči na matricu, s tim što je dataframe u snovi lista koja sadrži vektore jednakih dužina (kolone), pri čemu ti vektori ne moraju biti istog tipa. Dakle možemo imati jednu kolonu koju čine brojevi, a drugu tekstualni podaci. Dataframe se pravi na sledeći način: df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;)) df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Ovako smo dobili dataframe sa dve kolone, od kojih je jedna numerička a druga tekstualna. str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: Factor w/ 3 levels &quot;drugi&quot;,&quot;prvi&quot;,..: 2 1 3 R podrazumevano pretvara tekstualne podatke u faktore, to možemo preduprediti ako dodamo argument stringsAsFactors = FALSE. df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: chr &quot;prvi&quot; &quot;drugi&quot; &quot;treci&quot; df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Dva dataframe-a (koji imaju isi broj kolona) se mogu spojiti da dobijemo više kolona korišćenjem funkcije cbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona3 = c(4,5,6), kolona4 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df3 &lt;- cbind(df1, df2) df3 ## kolona1 kolona2 kolona3 kolona4 ## 1 1 prvi 4 prvi1 ## 2 2 drugi 5 drugi1 ## 3 3 treci 6 treci1 Takodje, mogu se nadovezati po vrstama (ako imaju ista imena kolona) funkcijom rbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona1 = c(4,5,6), kolona2 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df4 &lt;- rbind(df1, df2) df4 ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Vrednostima kolona možemo pristupati pomoću operatora $, kao u listama, a istim možemo i dodati nove kolone. df$kolona1 ## [1] 1 2 3 df$kolona5 &lt;- c(7,8,9) df ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 Medjutim, možda elegantniji način filtriranja i odabira podskupova dataframe-a je korišćenjem uglatih zagrada. Koristimo notaciju df[redovi, kolone], gde prvim argumentom odredjujemo koje redove želimo da uzmemo, a drugim koje kolone. Prazno mesto za neki od argumenata znači “uzmi sve”. df[,] # sve ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 df[1,] # prva vrsta ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 df[,1] # prva kolona ## [1] 1 2 3 Redovi mogu biti ili vektori brojeva koji označavaju indekse redova koje da uzmemo, ili vektori TRUE/FALSE vrednosti iste dužine kao broj vrsta u dataframe-u, pri čemu se tada biraju redovi na pozicijama gde je u vektoru vrednost TRUE. df4[c(1,3,4), ] # sve kolone, redovi 1,3,4 ## kolona1 kolona2 ## 1 1 prvi ## 3 3 treci ## 4 4 prvi1 df4[df4$kolona1 &gt; 3, ] # sve kolone, one vrste kod kojih je kolona1 veca od 3 ## kolona1 kolona2 ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Kolone mogu biti ili vektori brojeva koji označavaju koje kolone da uzmemo prema indeksu, ili vektori stringova, koji označavaju imena kolona koje da uzmemo. df3[, c(1,3)] # sve vrste, 1 i 3 kolona ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[, c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # isto ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[c(1,3), c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # prvi i treci red, prva i treca kolona ## kolona1 kolona3 ## 1 1 4 ## 3 3 6 Korisna stvar je da ako koristimo vektore brojeva za indeksiranje, ukoliko stavimo znak - ispred, to znači da izuzimamo te redove/kolone. df[, -1] # sve bez prve kolone ## kolona2 kolona5 ## 1 prvi 7 ## 2 drugi 8 ## 3 treci 9 df[-2, ] # sve bez druge vrste ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 3 3 treci 9 df[-c(1,2), c(&quot;kolona2&quot;, &quot;kolona5&quot;)] # druga i peta kolona, bez prve i druge vrste ## kolona2 kolona5 ## 3 treci 9 Konačno, za osnovne informacije o tabeli postoje funkcije colnames, rownames, ncol i nrow, za koje možete pretpostaviti šta rade. 3.2 Obrada podataka - dplyr paket Prethodno navedeni način rada sa tabelarnim podacima učitanim kao dataframe može postati prilično nezgrapan kod komplikovanijih zahteva, pa je stoga smišljen mnogo elegantniji pristup pomoću paketa dplyr. Uvodni tutorijal za paket možete naći i na https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html. Zansnovan je na korišćenju nekoliko osnovnih radnji koje se primenjuju na podacima, koje su implementirane funkcijama: select - biranje kolona iz tabele filter - filtriranje vrsta tabele arrange - sortiranje vrsta na osnovu nekih kolona mutate - pravljenje novih kolona korišćenjem postojećih summarise - računanje neke sumarne statistike (grupisanih) podataka Postoji i mnogo više funkcija u ovom paketu, koje su često slične navedenim i koje ćemo kad za to bude potrebe pokazati. Uz ovaj paket se upotrebljava malo čunija sintaksa, zasnovana na korišćenju operatora kompozicije %&gt;%. Najlakše ćemo pokazati primerom šta on radi. Uzmimo pomoću paketa dplyr kolonu 1 iz našeg dataframe-a. library(dplyr) df %&gt;% select(kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Ovo je ekvivalentno pozivu select(df, kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Operator %&gt;% radi tako što prosledjuje levi operand kao prvi argument funkcije date sa desne strane operatora, pa ostale argumente prosledjuje kao dodatne. Suštinski, kod x %&gt;% f(y) postaje f(x, y). Ako želimo da specifikujemo gde hoćemo da stavimo levu stranu operatora, koristimo .. Na primer, gornji kod je ekvivalentan df %&gt;% select(., kolona1) ## kolona1 ## 1 1 ## 2 2 ## 3 3 Vremenom će postati ovakva sintaksa prirodna. Vrlo je elegantna jer omogućava jednostavno nadovezivanje. Na sledeći način iz df izaberemo prve dve kolone i filtriramo da uzmemo vrste gde je prva kolona veća od 1. df %&gt;% select(kolona1, kolona2) %&gt;% filter(kolona1 &gt; 1) ## kolona1 kolona2 ## 1 2 drugi ## 2 3 treci Ovime smo videli već primere korišćenja dve funkcije u dplyr paketu - select i filter. 3.3 Učitavanje eksternih podataka Prikažimo mogućnosti paketa dplyr kroz istraživanje podataka o životnom veku u državama, poteklih od Svetske zdravstvene organizacije. Podaci koje ćemo posmatrati su dostupni na https://www.kaggle.com/kumarajarshi/life-expectancy-who. Kada preuzmemo podatke, učitavamo ih funkcijom read.csv: who_data &lt;- read.csv(&quot;Life Expectancy Data.csv&quot;) who_data %&gt;% sample_n(15) # stampamo 15 slucajno izabranih ## Country Year Status ## 1 Finland 2014 Developing ## 2 United Kingdom of Great Britain and Northern Ireland 2006 Developed ## 3 Dominican Republic 2006 Developing ## 4 Angola 2011 Developing ## 5 Tonga 2004 Developing ## 6 Argentina 2000 Developing ## 7 Georgia 2010 Developing ## 8 Belarus 2011 Developing ## 9 Saint Lucia 2004 Developing ## 10 Azerbaijan 2003 Developing ## 11 Botswana 2005 Developing ## 12 Mozambique 2000 Developing ## 13 Swaziland 2004 Developing ## 14 Republic of Moldova 2011 Developing ## 15 Romania 2002 Developed ## Life.expectancy Adult.Mortality infant.deaths Alcohol ## 1 89.0 78 0 8.80 ## 2 79.3 82 4 11.61 ## 3 72.3 178 7 6.20 ## 4 51.0 361 75 8.06 ## 5 72.2 151 0 1.80 ## 6 74.1 137 12 7.68 ## 7 73.8 132 1 7.24 ## 8 72.0 232 0 17.31 ## 9 72.6 166 0 11.93 ## 10 67.8 154 7 0.55 ## 11 51.7 566 2 6.37 ## 12 49.0 43 93 1.14 ## 13 45.6 69 3 5.78 ## 14 77.0 177 1 9.45 ## 15 77.0 178 4 9.62 ## percentage.expenditure Hepatitis.B Measles BMI under.five.deaths Polio ## 1 6164.45540 NA 0 61.7 0 98 ## 2 0.00000 NA 764 61.3 4 92 ## 3 352.95513 84 0 49.3 8 88 ## 4 239.89139 72 1449 21.0 115 73 ## 5 423.29535 9 0 68.6 0 91 ## 6 1349.02528 NA 6 54.0 14 88 ## 7 194.17327 95 22 52.0 1 88 ## 8 846.91131 98 50 59.9 1 98 ## 9 0.00000 91 0 39.0 0 91 ## 10 42.41491 51 1978 43.6 8 79 ## 11 629.84256 92 5 32.7 3 96 ## 12 47.17251 NA 7375 16.5 136 69 ## 13 37.43858 93 0 27.4 4 88 ## 14 0.00000 96 0 5.9 1 96 ## 15 37.82275 99 14 52.4 5 98 ## Total.expenditure Diphtheria HIV.AIDS GDP Population ## 1 9.68 98 0.1 49914.6186 5461512 ## 2 8.36 92 0.1 NA NA ## 3 4.34 89 1.8 3836.4688 9371338 ## 4 3.38 71 2.5 4299.1289 24218565 ## 5 4.87 9 0.1 2284.3786 146 ## 6 9.21 83 0.1 7669.2739 3757452 ## 7 1.50 92 0.1 2964.4773 3926 ## 8 4.92 98 0.1 6519.7175 9473172 ## 9 6.20 91 0.2 NA NA ## 10 6.56 77 0.1 883.6440 82341 ## 11 5.62 96 20.6 5351.2537 1855852 ## 12 6.16 7 12.2 277.6487 1867687 ## 13 5.88 86 50.3 2529.6336 19553 ## 14 1.61 93 0.1 NA NA ## 15 4.57 98 0.1 2124.8736 2173496 ## thinness..1.19.years thinness.5.9.years Income.composition.of.resources ## 1 0.9 0.8 0.890 ## 2 0.7 0.5 NA ## 3 3.5 3.4 0.677 ## 4 8.9 8.8 0.495 ## 5 0.1 0.1 0.693 ## 6 1.2 1.1 0.764 ## 7 2.6 2.8 0.738 ## 8 2.0 2.1 0.787 ## 9 4.4 4.4 0.686 ## 10 3.0 3.0 0.659 ## 11 1.0 9.9 0.593 ## 12 4.2 4.1 0.291 ## 13 7.7 7.9 0.492 ## 14 2.8 3.0 NA ## 15 3.7 4.1 0.714 ## Schooling ## 1 17.0 ## 2 NA ## 3 12.6 ## 4 9.4 ## 5 14.6 ## 6 15.0 ## 7 13.3 ## 8 15.5 ## 9 12.3 ## 10 10.8 ## 11 11.9 ## 12 5.4 ## 13 9.4 ## 14 NA ## 15 12.0 Paket dplyr koristi malo bogatiju strukturu umesto dataframe-a za tabelarne podatke, a to je tibble. Podatke pretvaramo u taj format na sledeći način: who_data &lt;- as_tibble(who_data) who_data ## # A tibble: 2,938 x 22 ## Country Year Status Life.expectancy Adult.Mortality infant.deaths ## &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghan… 2015 Devel… 65 263 62 ## 2 Afghan… 2014 Devel… 59.9 271 64 ## 3 Afghan… 2013 Devel… 59.9 268 66 ## 4 Afghan… 2012 Devel… 59.5 272 69 ## 5 Afghan… 2011 Devel… 59.2 275 71 ## 6 Afghan… 2010 Devel… 58.8 279 74 ## 7 Afghan… 2009 Devel… 58.6 281 77 ## 8 Afghan… 2008 Devel… 58.1 287 80 ## 9 Afghan… 2007 Devel… 57.5 295 82 ## 10 Afghan… 2006 Devel… 57.3 295 84 ## # … with 2,928 more rows, and 16 more variables: Alcohol &lt;dbl&gt;, ## # percentage.expenditure &lt;dbl&gt;, Hepatitis.B &lt;int&gt;, Measles &lt;int&gt;, ## # BMI &lt;dbl&gt;, under.five.deaths &lt;int&gt;, Polio &lt;int&gt;, ## # Total.expenditure &lt;dbl&gt;, Diphtheria &lt;int&gt;, HIV.AIDS &lt;dbl&gt;, GDP &lt;dbl&gt;, ## # Population &lt;dbl&gt;, thinness..1.19.years &lt;dbl&gt;, ## # thinness.5.9.years &lt;dbl&gt;, Income.composition.of.resources &lt;dbl&gt;, ## # Schooling &lt;dbl&gt; Vidimo blage razlike u prikazu. Korisno je pogledati podatke funkcijom glimpse (iz dplyr), gde vidimo tip promenljivih i prvih nekoliko podataka iz odgovarajuće kolone. glimpse(who_data) ## Observations: 2,938 ## Variables: 22 ## $ Country &lt;fct&gt; Afghanistan, Afghanistan, Afghan… ## $ Year &lt;int&gt; 2015, 2014, 2013, 2012, 2011, 20… ## $ Status &lt;fct&gt; Developing, Developing, Developi… ## $ Life.expectancy &lt;dbl&gt; 65.0, 59.9, 59.9, 59.5, 59.2, 58… ## $ Adult.Mortality &lt;int&gt; 263, 271, 268, 272, 275, 279, 28… ## $ infant.deaths &lt;int&gt; 62, 64, 66, 69, 71, 74, 77, 80, … ## $ Alcohol &lt;dbl&gt; 0.01, 0.01, 0.01, 0.01, 0.01, 0.… ## $ percentage.expenditure &lt;dbl&gt; 71.279624, 73.523582, 73.219243,… ## $ Hepatitis.B &lt;int&gt; 65, 62, 64, 67, 68, 66, 63, 64, … ## $ Measles &lt;int&gt; 1154, 492, 430, 2787, 3013, 1989… ## $ BMI &lt;dbl&gt; 19.1, 18.6, 18.1, 17.6, 17.2, 16… ## $ under.five.deaths &lt;int&gt; 83, 86, 89, 93, 97, 102, 106, 11… ## $ Polio &lt;int&gt; 6, 58, 62, 67, 68, 66, 63, 64, 6… ## $ Total.expenditure &lt;dbl&gt; 8.16, 8.18, 8.13, 8.52, 7.87, 9.… ## $ Diphtheria &lt;int&gt; 65, 62, 64, 67, 68, 66, 63, 64, … ## $ HIV.AIDS &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.… ## $ GDP &lt;dbl&gt; 584.25921, 612.69651, 631.74498,… ## $ Population &lt;dbl&gt; 33736494, 327582, 31731688, 3696… ## $ thinness..1.19.years &lt;dbl&gt; 17.2, 17.5, 17.7, 17.9, 18.2, 18… ## $ thinness.5.9.years &lt;dbl&gt; 17.3, 17.5, 17.7, 18.0, 18.2, 18… ## $ Income.composition.of.resources &lt;dbl&gt; 0.479, 0.476, 0.470, 0.463, 0.45… ## $ Schooling &lt;dbl&gt; 10.1, 10.0, 9.9, 9.8, 9.5, 9.2, … Sumarne podatke po kolonama vidimo ugradjenom funkcijom summary. summary(who_data) ## Country Year Status ## Afghanistan : 16 Min. :2000 Developed : 512 ## Albania : 16 1st Qu.:2004 Developing:2426 ## Algeria : 16 Median :2008 ## Angola : 16 Mean :2008 ## Antigua and Barbuda: 16 3rd Qu.:2012 ## Argentina : 16 Max. :2015 ## (Other) :2842 ## Life.expectancy Adult.Mortality infant.deaths Alcohol ## Min. :36.30 Min. : 1.0 Min. : 0.0 Min. : 0.0100 ## 1st Qu.:63.10 1st Qu.: 74.0 1st Qu.: 0.0 1st Qu.: 0.8775 ## Median :72.10 Median :144.0 Median : 3.0 Median : 3.7550 ## Mean :69.22 Mean :164.8 Mean : 30.3 Mean : 4.6029 ## 3rd Qu.:75.70 3rd Qu.:228.0 3rd Qu.: 22.0 3rd Qu.: 7.7025 ## Max. :89.00 Max. :723.0 Max. :1800.0 Max. :17.8700 ## NA&#39;s :10 NA&#39;s :10 NA&#39;s :194 ## percentage.expenditure Hepatitis.B Measles BMI ## Min. : 0.000 Min. : 1.00 Min. : 0.0 Min. : 1.00 ## 1st Qu.: 4.685 1st Qu.:77.00 1st Qu.: 0.0 1st Qu.:19.30 ## Median : 64.913 Median :92.00 Median : 17.0 Median :43.50 ## Mean : 738.251 Mean :80.94 Mean : 2419.6 Mean :38.32 ## 3rd Qu.: 441.534 3rd Qu.:97.00 3rd Qu.: 360.2 3rd Qu.:56.20 ## Max. :19479.912 Max. :99.00 Max. :212183.0 Max. :87.30 ## NA&#39;s :553 NA&#39;s :34 ## under.five.deaths Polio Total.expenditure Diphtheria ## Min. : 0.00 Min. : 3.00 Min. : 0.370 Min. : 2.00 ## 1st Qu.: 0.00 1st Qu.:78.00 1st Qu.: 4.260 1st Qu.:78.00 ## Median : 4.00 Median :93.00 Median : 5.755 Median :93.00 ## Mean : 42.04 Mean :82.55 Mean : 5.938 Mean :82.32 ## 3rd Qu.: 28.00 3rd Qu.:97.00 3rd Qu.: 7.492 3rd Qu.:97.00 ## Max. :2500.00 Max. :99.00 Max. :17.600 Max. :99.00 ## NA&#39;s :19 NA&#39;s :226 NA&#39;s :19 ## HIV.AIDS GDP Population ## Min. : 0.100 Min. : 1.68 Min. :3.400e+01 ## 1st Qu.: 0.100 1st Qu.: 463.94 1st Qu.:1.958e+05 ## Median : 0.100 Median : 1766.95 Median :1.387e+06 ## Mean : 1.742 Mean : 7483.16 Mean :1.275e+07 ## 3rd Qu.: 0.800 3rd Qu.: 5910.81 3rd Qu.:7.420e+06 ## Max. :50.600 Max. :119172.74 Max. :1.294e+09 ## NA&#39;s :448 NA&#39;s :652 ## thinness..1.19.years thinness.5.9.years Income.composition.of.resources ## Min. : 0.10 Min. : 0.10 Min. :0.0000 ## 1st Qu.: 1.60 1st Qu.: 1.50 1st Qu.:0.4930 ## Median : 3.30 Median : 3.30 Median :0.6770 ## Mean : 4.84 Mean : 4.87 Mean :0.6276 ## 3rd Qu.: 7.20 3rd Qu.: 7.20 3rd Qu.:0.7790 ## Max. :27.70 Max. :28.60 Max. :0.9480 ## NA&#39;s :34 NA&#39;s :34 NA&#39;s :167 ## Schooling ## Min. : 0.00 ## 1st Qu.:10.10 ## Median :12.30 ## Mean :11.99 ## 3rd Qu.:14.30 ## Max. :20.70 ## NA&#39;s :163 3.4 Osnovne funkcije paketa dplyr Proći ćemo nekoliko primera osnovnih funkcija iz paketa. Najviše ćemo koristiti podatke iz paketa nycflights13, pa ga učitavamo library(nycflights13) Prelazimo na pregled funkcija. 3.4.1 select - odabir kolona Sa ovom funkcijom smo se već susreli i nećemo dužiti. Ona služi da iz tabele koja ima mnogo kolona odaberemo samo one koje su nam od interesa, radi lakšeg pregleda. Odaberimo iz baze flights samo kolone godina, mesec, dan, polazipte i destinacija. flights %&gt;% select(year, month, day, origin, dest) ## # A tibble: 336,776 x 5 ## year month day origin dest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 EWR IAH ## 2 2013 1 1 LGA IAH ## 3 2013 1 1 JFK MIA ## 4 2013 1 1 JFK BQN ## 5 2013 1 1 LGA ATL ## 6 2013 1 1 EWR ORD ## 7 2013 1 1 EWR FLL ## 8 2013 1 1 LGA IAD ## 9 2013 1 1 JFK MCO ## 10 2013 1 1 LGA ORD ## # … with 336,766 more rows 3.4.2 filter - Filtriranje redova Ova funkcija služi za odabir odgovarajućih vrsta tabele, tj. opservacija, na osnovu željenih kriterijuma. Kao primer, možemo da izdvojimo iz baze letova one letove koji idu ka Portlandu, sa kodom aerodroma &quot;PDX&quot;. portland_flights &lt;- flights %&gt;% filter(dest == &quot;PDX&quot;) #View(portland_flights) Kao argument funkciji filter prosledjuje se uslov koji želimo da ispunjavaju redovi koje biramo. To je zapravo vektor TRUE i FALSE vrednosti, kao kod indeksiranja klasičnog dataframe-a. Ovde smo koristili operator jednakosti ==, ali možemo koristiti i druge matematičke operatore poput &gt;, &lt;, &gt;=, &lt;=, !=. Više kriterijuma možemo spajati operatorima konjukcije &amp; (‘i’) i disjunkcije | (‘ili’). Naravno, pored ovih, mogu se koristiti bilo koje funkcije koje daju kao rezultat logičke vektore. Na primer, možemo da odaberemo letove koji kreću sa aerodroma JFK, a leteli su duže od sat vremena. flights %&gt;% filter(origin == &quot;JFK&quot; &amp; air_time &gt; 60) ## # A tibble: 86,058 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 542 540 2 923 ## 2 2013 1 1 544 545 -1 1004 ## 3 2013 1 1 557 600 -3 838 ## 4 2013 1 1 558 600 -2 849 ## 5 2013 1 1 558 600 -2 853 ## 6 2013 1 1 558 600 -2 924 ## 7 2013 1 1 606 610 -4 837 ## 8 2013 1 1 611 600 11 945 ## 9 2013 1 1 613 610 3 925 ## 10 2013 1 1 615 615 0 1039 ## # … with 86,048 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Odredimo sve letove sa JFK do Berlingtona (BTV) i Sijetla (SEA), koji su od oktobra do kraja godine. btv_sea_flights &lt;- flights %&gt;% filter(origin == &quot;JFK&quot; &amp; (dest == &quot;BTV&quot; | dest == &quot;SEA&quot;) &amp; month &gt;= 10) #View(btv_sea_flights) Umesto korišćenja operatora konjunkcije, možemo samo razdvojiti sve uslove koji moraju biti zadovoljeni sa zapetom. btv_sea_flights &lt;- flights %&gt;% filter(origin == &quot;JFK&quot;, (dest == &quot;BTV&quot; | dest == &quot;SEA&quot;), month &gt;= 10) #View(btv_sea_flights) 3.4.3 arrange - sortiranje redova Često ima smisla sortirati podatke u odnosu na neku kolonu prilikom istraživanja podataka. Paket dplyr nam daje jednostavan način za to kroz funkciju arrange. Par jednostavnih primera sledi. Sortirajmo letove po trajanju leta rastuće… flights %&gt;% arrange(air_time) %&gt;% select(tailnum, air_time) ## # A tibble: 336,776 x 2 ## tailnum air_time ## &lt;chr&gt; &lt;dbl&gt; ## 1 N16911 20 ## 2 N12167 20 ## 3 N27200 21 ## 4 N13913 21 ## 5 N13955 21 ## 6 N12921 21 ## 7 N947UW 21 ## 8 N8501F 21 ## 9 N12160 21 ## 10 N16987 21 ## # … with 336,766 more rows … ili opadajuće flights %&gt;% arrange(desc(air_time)) %&gt;% select(tailnum, air_time) ## # A tibble: 336,776 x 2 ## tailnum air_time ## &lt;chr&gt; &lt;dbl&gt; ## 1 N77066 695 ## 2 N389HA 691 ## 3 N388HA 686 ## 4 N380HA 686 ## 5 N384HA 683 ## 6 N386HA 679 ## 7 N59053 676 ## 8 N380HA 676 ## 9 N386HA 675 ## 10 N76065 671 ## # … with 336,766 more rows Vrlo korisna opcija je što se sortiranje može vršiti po više promenljivih. Na primer, da bismo sortirali letove po datumu leta, počevši od najskorijeg, treba da sortiramo prvo opadajuće po mesecu, ali i one iz istog meseca treba sortirati opadajuće po danu. Ovo radimo na sledeći način # radi lakseg pregleda, uzecemo podskup od # 10 letova set.seed(1) subflights &lt;- flights %&gt;% sample_n(10) subflights %&gt;% arrange(desc(month), desc(day)) %&gt;% select(tailnum, month, day) ## # A tibble: 10 x 3 ## tailnum month day ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 N855UA 9 25 ## 2 N624JB 8 16 ## 3 N725MQ 7 22 ## 4 N328AA 3 7 ## 5 N13716 2 15 ## 6 N176PQ 2 7 ## 7 N756US 1 30 ## 8 N14237 1 29 ## 9 &lt;NA&gt; 1 29 ## 10 N10156 1 16 Napomena! Obratite pažnju, bitan je redosled argumenata u arrange, ako sortiramo prvo po danu pa po mesecu, ne dobijamo željeni rezultat. subflights %&gt;% arrange(desc(day), desc(month)) %&gt;% select(tailnum, month, day) ## # A tibble: 10 x 3 ## tailnum month day ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 N756US 1 30 ## 2 N14237 1 29 ## 3 &lt;NA&gt; 1 29 ## 4 N855UA 9 25 ## 5 N725MQ 7 22 ## 6 N624JB 8 16 ## 7 N10156 1 16 ## 8 N13716 2 15 ## 9 N328AA 3 7 ## 10 N176PQ 2 7 Sortirajmo letove opadajuće po datumu, ali rastuće po trajanju leta flights %&gt;% arrange(desc(month), desc(day), air_time) %&gt;% select(tailnum, month, day, air_time) ## # A tibble: 336,776 x 4 ## tailnum month day air_time ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 N952UW 12 31 28 ## 2 N13975 12 31 29 ## 3 N197JB 12 31 32 ## 4 N304JB 12 31 32 ## 5 N76514 12 31 32 ## 6 N236JB 12 31 32 ## 7 N329JB 12 31 33 ## 8 N351JB 12 31 33 ## 9 N3JAAA 12 31 33 ## 10 N206JB 12 31 33 ## # … with 336,766 more rows 3.4.4 mutate - dodavanje nove kolone Ovom funkcijom možemo da napravimo nove kolone koristeći postojeće. Na primer, možemo da vršimo konverziju iz Farenhajta u Celzijus. # ovako smo ranije # weather$celsius &lt;- (weather$temp - 32) * 5 / 9 # dplyr nacin: weather &lt;- weather %&gt;% mutate(celsius = (temp - 32) * 5 / 9) #View(weather) Možemo praviti više novih kolona odjednom. Na primer, dodaćemo kolonu “gain” koja predstavlja razliku izmedju kašnjenja polaska i kašnjenja dolaska, tj. neki vid nadoknadjenog vremena kada je let kasnio sa polaskom. Pored toga, dodaćemo kolonu koja predstavlja let u satima, i odrediti i “gain” po satu. flights &lt;- flights %&gt;% mutate( gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) I sortiramo po gain_per_hour flights %&gt;% arrange(gain_per_hour) %&gt;% select(dep_delay, arr_delay, gain, hours, air_time, gain_per_hour) ## # A tibble: 336,776 x 6 ## dep_delay arr_delay gain hours air_time gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 171 273 -102 0.517 31 -197. ## 2 62 177 -115 0.6 36 -192. ## 3 11 122 -111 0.6 36 -185 ## 4 115 233 -118 0.667 40 -177 ## 5 -7 106 -113 0.65 39 -174. ## 6 -8 123 -131 0.767 46 -171. ## 7 -1 109 -110 0.65 39 -169. ## 8 39 152 -113 0.7 42 -161. ## 9 3 94 -91 0.567 34 -161. ## 10 33 136 -103 0.65 39 -158. ## # … with 336,766 more rows Ako uposlimo i paket lubridate, koji značajno olakšava rad sa datumima u R-u, možemo dodati i kolonu koja sadrži tačno vreme leta, umesto komponenti koje imamo sada. #install.packages(&quot;lubridate&quot;) library(lubridate) flights &lt;- flights %&gt;% mutate(departure = make_datetime(year, month, day, hour, minute)) flights %&gt;% select(year, month, day, hour, minute, departure) ## # A tibble: 336,776 x 6 ## year month day hour minute departure ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 2013 1 1 5 15 2013-01-01 05:15:00 ## 2 2013 1 1 5 29 2013-01-01 05:29:00 ## 3 2013 1 1 5 40 2013-01-01 05:40:00 ## 4 2013 1 1 5 45 2013-01-01 05:45:00 ## 5 2013 1 1 6 0 2013-01-01 06:00:00 ## 6 2013 1 1 5 58 2013-01-01 05:58:00 ## 7 2013 1 1 6 0 2013-01-01 06:00:00 ## 8 2013 1 1 6 0 2013-01-01 06:00:00 ## 9 2013 1 1 6 0 2013-01-01 06:00:00 ## 10 2013 1 1 6 0 2013-01-01 06:00:00 ## # … with 336,766 more rows Sada prethodno sortiranje opadajuće možemo odratiti po toj novoj koloni. set.seed(1) flights %&gt;% sample_n(10) %&gt;% arrange(desc(departure)) %&gt;% select(tailnum, month, day, departure) ## # A tibble: 10 x 4 ## tailnum month day departure ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dttm&gt; ## 1 N855UA 9 25 2013-09-25 14:17:00 ## 2 N624JB 8 16 2013-08-16 12:41:00 ## 3 N725MQ 7 22 2013-07-22 08:30:00 ## 4 N328AA 3 7 2013-03-07 21:35:00 ## 5 N13716 2 15 2013-02-15 20:48:00 ## 6 N176PQ 2 7 2013-02-07 06:15:00 ## 7 N756US 1 30 2013-01-30 08:00:00 ## 8 &lt;NA&gt; 1 29 2013-01-29 19:00:00 ## 9 N14237 1 29 2013-01-29 07:15:00 ## 10 N10156 1 16 2013-01-16 19:35:00 Specijalan slučaj mutate naredbe je rename koju koristimo za preimenovanje kolona. weather %&gt;% rename(temp_C = celsius) ## # A tibble: 26,115 x 16 ## origin year month day hour temp dewp humid wind_dir wind_speed ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 2013 1 1 1 39.0 26.1 59.4 270 10.4 ## 2 EWR 2013 1 1 2 39.0 27.0 61.6 250 8.06 ## 3 EWR 2013 1 1 3 39.0 28.0 64.4 240 11.5 ## 4 EWR 2013 1 1 4 39.9 28.0 62.2 250 12.7 ## 5 EWR 2013 1 1 5 39.0 28.0 64.4 260 12.7 ## 6 EWR 2013 1 1 6 37.9 28.0 67.2 240 11.5 ## 7 EWR 2013 1 1 7 39.0 28.0 64.4 240 15.0 ## 8 EWR 2013 1 1 8 39.9 28.0 62.2 250 10.4 ## 9 EWR 2013 1 1 9 39.9 28.0 62.2 260 15.0 ## 10 EWR 2013 1 1 10 41 28.0 59.6 260 13.8 ## # … with 26,105 more rows, and 6 more variables: wind_gust &lt;dbl&gt;, ## # precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt;, ## # temp_C &lt;dbl&gt; 3.4.5 summarise - sumarne statistike Ova, jedna od korisnijih funkcija, služi za računanje neke statistike nad podacima. Podaci mogu biti i grupisani, što ćemo videti kasnije. Za početak, vidimo neki prosti primer. Prosečno vreme trajanja letova dobijamo ovako: flights %&gt;% summarise(mean(air_time)) ## # A tibble: 1 x 1 ## `mean(air_time)` ## &lt;dbl&gt; ## 1 NA Ima NA vrednosti, pa dodajemo na.rm = TRUE, da bi ih ignorisali prilikom računa. flights %&gt;% summarise(mean(air_time, na.rm = TRUE)) ## # A tibble: 1 x 1 ## `mean(air_time, na.rm = TRUE)` ## &lt;dbl&gt; ## 1 151. Da vidimo i ukupan broj letova, koristimo specijalnu funkciju n(). Dodajmo i kvantile iz poziva summary. no_na_flights &lt;- flights %&gt;% filter(!is.na(air_time)) no_na_flights %&gt;% summarise( count = n(), min_time = min(air_time), time_q1 = quantile(air_time, 0.25), median_time = median(air_time), mean_time = mean(air_time), time_13 = quantile(air_time, 0.75), max_time = max(air_time) ) ## # A tibble: 1 x 7 ## count min_time time_q1 median_time mean_time time_13 max_time ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 327346 20 82 129 151. 192 695 Vidimo poklapanje sa summary. summary(no_na_flights$air_time) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 20.0 82.0 129.0 150.7 192.0 695.0 3.4.6 group_by - grupisanje opservacija Često je potrebno, posebno za sumarizavije, da grupišemo podatke u odnosu na neku promenljivu, da bismo videli svojstva odgovarajućih grupa. Na primer, možda želimo da vidimo prosečnu temperaturu po mesecima iz skupa podataka weather, umesto sveukupnog proseka temperature u celoj tabeli. To radimo uz pomoć funkcije group_by. library(nycflights13) library(dplyr) weather %&gt;% group_by(month) %&gt;% summarise(mean_temp = mean(temp, na.rm = TRUE), stdev_temp = sd(temp, na.rm = TRUE)) ## # A tibble: 12 x 3 ## month mean_temp stdev_temp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 35.6 10.2 ## 2 2 34.3 6.98 ## 3 3 39.9 6.25 ## 4 4 51.7 8.79 ## 5 5 61.8 9.68 ## 6 6 72.2 7.55 ## 7 7 80.1 7.12 ## 8 8 74.5 5.19 ## 9 9 67.4 8.47 ## 10 10 60.1 8.85 ## 11 11 45.0 10.4 ## 12 12 38.4 9.98 Ovo naravno možemo i prikazati grafiički pomoću bar plota. library(ggplot2) weather %&gt;% group_by(month) %&gt;% summarise(mean_temp = mean(temp, na.rm = TRUE), stdev_temp = sd(temp, na.rm = TRUE)) %&gt;% ggplot(aes(x = month, y = mean_temp)) + geom_col() Analizirajmo malo dijamante. U ggplot2 paketu postoji skup podataka diamonds. diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows glimpse(diamonds) ## Observations: 53,940 ## Variables: 10 ## $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.… ## $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Goo… ## $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J,… ## $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1,… ## $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59… ## $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, … ## $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 3… ## $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.… ## $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.… ## $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.… Pogledajmo cenu u zavisnosti kvaliteta (promenljiva cut) diamonds %&gt;% group_by(cut) %&gt;% summarise(avg_price = mean(price)) ## # A tibble: 5 x 2 ## cut avg_price ## &lt;ord&gt; &lt;dbl&gt; ## 1 Fair 4359. ## 2 Good 3929. ## 3 Very Good 3982. ## 4 Premium 4584. ## 5 Ideal 3458. Pogledajmo malo kako radi group_by. Ideja je da od originalnog dataframe-a napravi grupisani dataframe kod koga se operacije primenjuju na svaku grupu ponaosob, umesto kolektivno na celu tabelu. diamonds_by_cut &lt;- diamonds %&gt;% group_by(cut) diamonds_by_cut ## # A tibble: 53,940 x 10 ## # Groups: cut [5] ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows Ovaj dataframe je u suštini isti kao ranije, samo što je naznačeno da se grupiše po promenljivoj cut. Svaka operacija se sada na ovaj dataframe primenjuje na svaku grupu, npr, da vidimo broj elemenata: # grupisano diamonds_by_cut %&gt;% summarise(n()) ## # A tibble: 5 x 2 ## cut `n()` ## &lt;ord&gt; &lt;int&gt; ## 1 Fair 1610 ## 2 Good 4906 ## 3 Very Good 12082 ## 4 Premium 13791 ## 5 Ideal 21551 # negrupisano diamonds %&gt;% # moze i ungroup(diamonds_by_cut) summarise(n()) ## # A tibble: 1 x 1 ## `n()` ## &lt;int&gt; ## 1 53940 Nisu sumarizacije jedina opcija. Možemo i odabrati podatak kod koga je najveća cena u svakoj grupi. diamonds_by_cut %&gt;% filter(price == max(price)) ## # A tibble: 5 x 10 ## # Groups: cut [5] ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2.01 Fair G SI1 70.6 64 18574 7.43 6.64 4.69 ## 2 2.8 Good G SI2 63.8 58 18788 8.9 8.85 0 ## 3 1.51 Ideal G IF 61.7 55 18806 7.37 7.41 4.56 ## 4 2 Very Good G SI1 63.5 56 18818 7.9 7.97 5.04 ## 5 2.29 Premium I VS2 60.8 60 18823 8.5 8.47 5.16 Primetimo, ovde biramo celu vrstu, ne gledamo samo koliki je maksimum. Dakle, možemo i filtrirati po grupama. Uzmimo iz svake grupe 0.0001% najskupljih. diamonds_by_cut %&gt;% filter(price &gt; quantile(price, 0.9999)) %&gt;% arrange(cut) ## # A tibble: 9 x 10 ## # Groups: cut [5] ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2.01 Fair G SI1 70.6 64 18574 7.43 6.64 4.69 ## 2 2.8 Good G SI2 63.8 58 18788 8.9 8.85 0 ## 3 2 Very Good H SI1 62.8 57 18803 7.95 8 5.01 ## 4 2 Very Good G SI1 63.5 56 18818 7.9 7.97 5.04 ## 5 2.29 Premium I SI1 61.8 59 18797 8.52 8.45 5.24 ## 6 2.29 Premium I VS2 60.8 60 18823 8.5 8.47 5.16 ## 7 2.15 Ideal G SI2 62.6 54 18791 8.29 8.35 5.21 ## 8 2.07 Ideal G SI2 62.5 55 18804 8.2 8.13 5.11 ## 9 1.51 Ideal G IF 61.7 55 18806 7.37 7.41 4.56 Vidimo da ovo nije isto kao negrupisani poziv, gde su &quot;Fair&quot; i &quot;Good&quot; kvaliteti izostavljeni. ungroup(diamonds_by_cut) %&gt;% filter(price &gt; quantile(price, 0.9999)) %&gt;% arrange(cut) ## # A tibble: 6 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Very Good H SI1 62.8 57 18803 7.95 8 5.01 ## 2 2 Very Good G SI1 63.5 56 18818 7.9 7.97 5.04 ## 3 2.29 Premium I SI1 61.8 59 18797 8.52 8.45 5.24 ## 4 2.29 Premium I VS2 60.8 60 18823 8.5 8.47 5.16 ## 5 2.07 Ideal G SI2 62.5 55 18804 8.2 8.13 5.11 ## 6 1.51 Ideal G IF 61.7 55 18806 7.37 7.41 4.56 Bolje od kvantila je da koristimo funkciju top_n, za top 2 najskuplja po kvalitetu diamonds_by_cut %&gt;% top_n(2, price) %&gt;% arrange(cut) ## # A tibble: 10 x 10 ## # Groups: cut [5] ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2.02 Fair H VS2 64.5 57 18565 8 7.95 5.14 ## 2 2.01 Fair G SI1 70.6 64 18574 7.43 6.64 4.69 ## 3 2.07 Good I VS2 61.8 61 18707 8.12 8.16 5.03 ## 4 2.8 Good G SI2 63.8 58 18788 8.9 8.85 0 ## 5 2 Very Good H SI1 62.8 57 18803 7.95 8 5.01 ## 6 2 Very Good G SI1 63.5 56 18818 7.9 7.97 5.04 ## 7 2.29 Premium I SI1 61.8 59 18797 8.52 8.45 5.24 ## 8 2.29 Premium I VS2 60.8 60 18823 8.5 8.47 5.16 ## 9 2.07 Ideal G SI2 62.5 55 18804 8.2 8.13 5.11 ## 10 1.51 Ideal G IF 61.7 55 18806 7.37 7.41 4.56 Poput sortiranja, i grupisanje se može vršiti po više promenljivih. Na primer, da se vratimo na naše avione, možemo da proverimo koliko je letova bilo u svakom mesecu, ali i njih da grupišemo po aerodromima sa kog su poleteli. flights %&gt;% group_by(origin, month) %&gt;% summarise(count = n()) ## # A tibble: 36 x 3 ## # Groups: origin [3] ## origin month count ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR 1 9893 ## 2 EWR 2 9107 ## 3 EWR 3 10420 ## 4 EWR 4 10531 ## 5 EWR 5 10592 ## 6 EWR 6 10175 ## 7 EWR 7 10475 ## 8 EWR 8 10359 ## 9 EWR 9 9550 ## 10 EWR 10 10104 ## # … with 26 more rows Možemo i izdvojiti 3 najprometnija meseca za svaki aerodrom. flights %&gt;% group_by(origin, month) %&gt;% summarise(count = n()) %&gt;% top_n(3, count) ## # A tibble: 9 x 3 ## # Groups: origin [3] ## origin month count ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR 4 10531 ## 2 EWR 5 10592 ## 3 EWR 7 10475 ## 4 JFK 3 9697 ## 5 JFK 7 10023 ## 6 JFK 8 9983 ## 7 LGA 9 9116 ## 8 LGA 10 9642 ## 9 LGA 12 9067 Kako ovo radi? Prilikom prvog poziva summarise “skinuli” smo zadnji sloj grupisanja, pa smo dobili dataframe grupisan samo po origin, pa na njemu top_n radi po grupama za polazni aerordrom. Stoga je bitan redosled grupisanja za ovakve operacije. 3.4.7 join - spajanje tabela Kada radimo sa dva povezana skupa podataka, nailazićemo na promenljive koje postoje u oba i po kojima bismo mogli ta dva skupa da spojimo u jednu tabelu. Dobar i dosta dublji tutorijal za join operacije je u okviru knjige R for Data Science, na ovom linku. Na primer, ako pogledamo tabele airlines i flights airlines ## # A tibble: 16 x 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. ## 7 F9 Frontier Airlines Inc. ## 8 FL AirTran Airways Corporation ## 9 HA Hawaiian Airlines Inc. ## 10 MQ Envoy Air ## 11 OO SkyWest Airlines Inc. ## 12 UA United Air Lines Inc. ## 13 US US Airways Inc. ## 14 VX Virgin America ## 15 WN Southwest Airlines Co. ## 16 YV Mesa Airlines Inc. flights ## # A tibble: 336,776 x 23 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 16 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, hours &lt;dbl&gt;, ## # gain_per_hour &lt;dbl&gt;, departure &lt;dttm&gt; vidimo da imaju kolonu carrier koja označava skraćenicu avio kompanije. Možemo dodati u tabelu flights puno ime avio kompanije koristeći informaciju u tabeli airlines: full_airline &lt;- flights %&gt;% inner_join(airlines, by = &quot;carrier&quot;) full_airline %&gt;% select(tailnum, carrier, name) ## # A tibble: 336,776 x 3 ## tailnum carrier name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 N14228 UA United Air Lines Inc. ## 2 N24211 UA United Air Lines Inc. ## 3 N619AA AA American Airlines Inc. ## 4 N804JB B6 JetBlue Airways ## 5 N668DN DL Delta Air Lines Inc. ## 6 N39463 UA United Air Lines Inc. ## 7 N516JB B6 JetBlue Airways ## 8 N829AS EV ExpressJet Airlines Inc. ## 9 N593JB B6 JetBlue Airways ## 10 N3ALAA AA American Airlines Inc. ## # … with 336,766 more rows Iskoristili smo funkciju inner_join ovaj put. Postoji više *_join funkcija u dplyr paketu, koje odgovaraju onima iz SQL jezika. Takodje, ova operacija je toliko popularna u SQL-u, da ima svoju adresu: http://www.sql-join.com/ (koja se može koristiti za razumevanje). Glavna razlika medju *_join funkcijama je: inner_join zadržava samo one redove za koje u obe tabele postoji vrednost, tj. koje je mogao da upari sa redovima iz druge tabele. left_join zadržava sve redove iz prve tabele, a tamo gde nema para stavi NA right_join zadržava sve redove iz druge tabele full_join zadržava sve redove iz obe tabele Na sledećoj slici vidi se grafički prikaz ovih operacija. Ilustracije raznih join operacija. Preuzeto sa https://r4ds.had.co.nz. Dakle, kod nas je više smisla imalo koristiti left_join, iako je isti rezultat ovaj put. full_airline &lt;- flights %&gt;% left_join(airlines, by = &quot;carrier&quot;) Pokazaćemo sada na primeru razlike izmedju ovih raznih vrsta join operacije. Koristimo primere preuzete sa uputstva na stranici https://stat545.com/bit001_dplyr-cheatsheet.html. Prvo kreiramo tabele library(readr) superheroes &lt;- &quot; name, alignment, gender, publisher Magneto, bad, male, Marvel Storm, good, female, Marvel Mystique, bad, female, Marvel Batman, good, male, DC Joker, bad, male, DC Catwoman, bad, female, DC Hellboy, good, male, Dark Horse Comics &quot; superheroes &lt;- read_csv(superheroes, skip = 1) publishers &lt;- &quot; publisher, yr_founded DC, 1934 Marvel, 1939 Image, 1992 &quot; publishers &lt;- read_csv(publishers, skip = 1) 3.4.7.1 Inner join Prvo da vidimo inner join inner_join(superheroes, publishers, by = &quot;publisher&quot;) ## # A tibble: 6 x 5 ## name alignment gender publisher yr_founded ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Magneto bad male Marvel 1939 ## 2 Storm good female Marvel 1939 ## 3 Mystique bad female Marvel 1939 ## 4 Batman good male DC 1934 ## 5 Joker bad male DC 1934 ## 6 Catwoman bad female DC 1934 Vidimo da fali Hellboy, jer Dark Horse Comics nije medju izdavačima u tabeli (a isto nema ni izdavača Image iz tabele izdavača, jer se ne pojavljuje medju herojima). 3.4.7.2 Left join Kod left join operacije, čuvamo originalnu tabelu u celosti i uparujemo sa drugom gde je moguće left_join(superheroes, publishers, by = &quot;publisher&quot;) ## # A tibble: 7 x 5 ## name alignment gender publisher yr_founded ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Magneto bad male Marvel 1939 ## 2 Storm good female Marvel 1939 ## 3 Mystique bad female Marvel 1939 ## 4 Batman good male DC 1934 ## 5 Joker bad male DC 1934 ## 6 Catwoman bad female DC 1934 ## 7 Hellboy good male Dark Horse Comics NA Sada kod Hellboy-a nemamo godinu osnivanja izdavača. jer ne postoji u tabeli. 3.4.7.3 Right join Pogledajmo right join. right_join(superheroes, publishers, by = &quot;publisher&quot;) ## # A tibble: 7 x 5 ## name alignment gender publisher yr_founded ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Batman good male DC 1934 ## 2 Joker bad male DC 1934 ## 3 Catwoman bad female DC 1934 ## 4 Magneto bad male Marvel 1939 ## 5 Storm good female Marvel 1939 ## 6 Mystique bad female Marvel 1939 ## 7 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Image 1992 Dodao je jedan red pun NA vrednosti, za izdavača Image, koji nije nadjen u prvoj tabeli. Svrha ove operacije je vrlo upitna, pa se retko i koristi. 3.4.7.4 Full join Full join prikazuje sve redove i upisuje NA tamo gde nešto fali full_join(superheroes, publishers, by = &quot;publisher&quot;) ## # A tibble: 8 x 5 ## name alignment gender publisher yr_founded ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Magneto bad male Marvel 1939 ## 2 Storm good female Marvel 1939 ## 3 Mystique bad female Marvel 1939 ## 4 Batman good male DC 1934 ## 5 Joker bad male DC 1934 ## 6 Catwoman bad female DC 1934 ## 7 Hellboy good male Dark Horse Comics NA ## 8 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Image 1992 Dakle imamo uniju left i right joina. "],
["21-mle.html", "4 Ocenjivanje metodom maksimalne verodostojnosti 4.1 Njutnova metoda", " 4 Ocenjivanje metodom maksimalne verodostojnosti Jedan od najpoznatijih metoda za odredjivanje ocena parametra neke raspodele je upravo metod maksimalne verodostojnosti. On nalazi primenu u svim primenama statistike, od testiranja hipoteza do mašinskog učenja. Osnovna postavka je sledeća: Neka je \\(\\mathbf{X}=(X_1, \\dots, X_n)\\) prost slučajan uzorak sa zajedničkom gustinom (ili zakonom raspodele) \\(f(\\mathbf x;\\theta)\\) gde je \\(\\theta\\) nepoznati parametar. Funkcija verodostojnosti se definiše kao \\[L(\\theta; \\mathbf x) = f(\\mathbf x;\\theta) = \\prod_{i=1}^nf(x_i,\\theta),\\] odnosno funkcija verodostojnosti je zajednička raspodela uzorka, posmatrana kao funkcija parametra \\(\\theta\\). Parametar može biti višedimenzioni (npr. \\((\\mu, \\sigma^2)\\) kod normalne raspodele), ali ćemo se mi baviti samo jednodimenzionim parametrima u ovom tekstu. Ocena maksimalne verodostojnosti parametra \\(\\theta\\) je \\[\\hat{\\theta} = \\underset{\\theta}{\\mathrm{argmax}}L(\\theta; \\mathbf x).\\] Dakle ocena metodom maksimalne verodostojnosti je ona vrednosti parametra za koju je funkcija verodostojnosti najveća. Da bismo našli ovaj maksimum, uglavnom prelazimo na traženje maksimuma logaritma funkcije verodostojnosti koji ima lepši oblik \\[l(\\theta) = \\log L(\\theta, \\mathbf x) = \\sum_{i=1}^n\\log f(x_i,\\theta).\\] Maksimum dalje nalazimo odredjivanjem stacionarne tačke \\(l(\\theta)\\), rešavanjem jednačine \\[\\frac{d}{d\\theta}l(\\theta) = 0.\\] U velikom broju slučajeva rešenje ove jednačine, a samim tim i ocena, se može naći analitički, kao u primerima radjenim na matematičkoj statistici, ali nekada rešenje nije dostupno u analitičkom obliku. U tom slučaju rešenje se mora naći numeričkim metodama. Jedan takav primer raspodele je Košijeva raspodela, koju ćemo koristiti za demonstraciju numeričkih metoda za nalaženje ocena maksimalne verodostojnosti. 4.1 Njutnova metoda Cilj Njutnove metode je da nadje nulu funkcije \\(f(x)\\), tj. da nadje rešenje jednačine \\[f(x) = 0.\\] Osnovna ideja metode je da se u svakoj iteraciji kriva \\(y=f(x)\\) aproksimira njenom tangentom i nadje nula te tangente, čime se dobija neka aproksimacija nule početne funkcije, sve dok se ne dostigne neki uslov zaustavljanja. Ako u \\(n\\)-toj iteraciji imamo aproksimaciju nule \\(x_n\\), novu aproksimaciju \\(x_{n+1}\\) dobijamo na sledeći način: Nadjemo tangentu krive \\(y=f(x)\\) u tački \\(x_n\\), koja ima oblik \\[y_t = f&#39;(x_n)(x-x_n)+f(x_n).\\] Aproksimacija u sledećoj iteraciji, \\(x_{n+1}\\), je nula te tangente, odnosno rešenje jednačine \\[0 = f&#39;(x_n)(x-x_n)+f(x_n),\\] odakle dobijamo \\[x_{n+1} = x_n - \\frac{f(x_n)}{f&#39;(x_n)}.\\] Pseudokod za Njutnovu metodu (nije u R-u!) izgleda ovako: function njutn(x0, f, df, tol, maxiter) { x = x0 - f(x0) / df(x0) iter = 1 while (abs(x - x0) &gt; tol) { if(iter == maxiter) break x0 = x x = x0 - f(x0) / df(x0) iter = iter + 1 } return x } 4.1.1 Primer Košijeve raspodele Primenićemo Njutnovu metodu za nalaženje ocene maksimalne verodostojnosi parametra \\(\\theta\\) uzorka iz Košijeve raspodele sa gustinom \\[f(x, \\theta)=\\frac{1}{\\pi}\\frac{1}{1+(x-\\theta)^2}.\\] Generisaćemo uzorak iz Košijeve raspodele za koji ćemo tražiti ocenu parametra. set.seed(21321) xs &lt;- rcauchy(1000, location = 10) Logaritam funkcije verodostojnosti je \\[l(\\theta) = -\\sum_{i=1}^n \\log(1+(x_i-\\theta)^2) - n\\log\\pi.\\] Definišimo je u R-u. logL &lt;- function(teta, x) { - sum(log(1+(x-teta)^2)) - length(x)*log(pi) } Za naš uzorak ova funkcija izgleda ovako # Da bismo primenili funkciju curve, moramo prvo vektorizovati logL vec_logL &lt;- function(teta_vec, xs) { sapply(teta_vec, logL, xs) } curve(vec_logL(x, xs), xlim = c(-10, 30)) Izvod logaritma funkcije verodostojnosti je \\[\\frac{d}{d\\theta}l(\\theta) = \\sum_{i=1}^n\\frac{2(x_i-\\theta)}{1+(x_i-\\theta)^2}.\\] dlogL &lt;- function(teta, x) { sum(2*(x-teta) / (1+(x-teta)^2)) } Izvod izgleda ovako vec_dlogL &lt;- function(teta_vec, xs) { sapply(teta_vec, dlogL, xs) } curve(vec_dlogL(x, xs), xlim = c(0, 20)) A kako smo rekli da je ocena maksimalne verodostojnosti rešenje jednačine \\(\\frac{d}{d\\theta}l(\\theta) = 0\\), to znači da je ocena upravo nule nacrtane funkcije. 4.1.1.1 Njutnova metoda Primenićemo Njutnovu metodu da nadjemo nulu funkcije \\(\\frac{d}{d\\theta}l(\\theta)\\). Za to nam još treba izvod funkcije čiju nulu tražimo, a to je u našem slučaju drugi izvod logaritma funkcije verodostojnosti \\[\\frac{d^2}{d\\theta^2}l(\\theta) = -2\\sum_{i=1}^n\\frac{1-(x_i-\\theta)^2}{(1+(x_i-\\theta)^2)^2}.\\] d2logL &lt;- function(teta, x) { -2*sum((1-(x-teta)^2) / (1+(x-teta)^2)^2) } Ostaje još samo da implementiramo funkciju koja nalazi nulu funkcije Njutnovom metodom newton &lt;- function(t0, f, df, tol=1e-6, maxiter=100, trace=FALSE, ...) { if (trace) print(t0) t &lt;- t0 - f(t0, ...) / df(t0, ...) if (trace) print(t) iter &lt;- 1 while (abs(t - t0) &gt; tol) { if(iter == maxiter) stop(&quot;Max iterations exceeded!&quot;) t0 &lt;- t t &lt;- t0 - f(t0, ...) / df(t0, ...) if (trace) print(t) iter &lt;- iter + 1 } return(t) } Na kraju, možemo odrediti ocenu metodom maksimalne verodostojnosti primenom Njutnove metode na izvod logaritma funkcije verodostojnosti newton(0, dlogL, d2logL, x = xs, maxiter=100) ## Error in newton(0, dlogL, d2logL, x = xs, maxiter = 100): Max iterations exceeded! # da bi stampali iteracije, dodajte trace=TRUE #newton(0, dlogL, d2logL, x = xs, maxiter=100, trace=TRUE) Ali avaj! Imamo grešku, algoritam divergira, a vrednosti u iteracijama postaju sve veće. Razlog za ovo je što smo loše odabrali početnu tačku 0. Njutnova metoda je vrlo osetljiva na odabir početne tačke, pa moramo uzeti neku smisleniju vrednost od koje da krenemo. Možemo probati razne vrednosti dok ne dobijemo konvergenciju, a možemo i iskoristiti to što je u ovom slučaju \\(\\theta\\) parametar položaja, pa možemo pretpostaviti da je u blizini uzoračke sredine ili medijane, pa ćemo probati sa tim vrednostima newton(mean(xs), dlogL, d2logL, x = xs, maxiter=100, trace=FALSE) ## Error in newton(mean(xs), dlogL, d2logL, x = xs, maxiter = 100, trace = FALSE): Max iterations exceeded! newton(median(xs), dlogL, d2logL, x = xs, maxiter=100, trace=TRUE) ## [1] 9.964994 ## [1] 9.939758 ## [1] 9.939738 ## [1] 9.939738 ## [1] 9.939738 Za prosek, koji je jednak 14.34 opet divergira algoritam, ali za medijanu koja je manje osetljiva na autlajere, kojih je mnogo zbog težine repova Košijeve raspodele, dobijamo konvergenciju. Intuitivno, algoritam će u ovom slučaju konvergirati ako za početnu vrednost uzmemo neku vrednosti na padini na grafiku, oko tačke 10, što je prava vrednost parametra. 4.1.1.2 Fišerova modifikacija Budući da znamo da je Fišerova informaciona funkcija za parametar \\(\\theta\\) jednaka \\[\\mathbf{I}(\\theta) =-E\\left(\\frac{d^2}{d\\theta^2}\\log L(\\theta; \\mathbf{x})\\right) = \\frac n2,\\] možemo je iskoristiti (sa znakom minusa) umesto drugog izvoda logaritma funkcije verodostojnosti, čime dobijamo Fišerovu modifikaciju Njutnovog metoda. Dakle, osnovna ideja je da umesto drugog izvoda koristimo očekivanje drugog izvoda, čime “uprosečujemo” uticaj uzorka na drugi izvod, pa dobijamo funkciju samo od parametra. # Fiserov &quot;drugi izvod&quot; fishd2logL &lt;- function(teta, x) { - length(x) / 2 } newton(median(xs), dlogL, fishd2logL, x = xs, maxiter=100, trace=TRUE) ## [1] 9.964994 ## [1] 9.939801 ## [1] 9.939738 ## [1] 9.939738 ## [1] 9.939738 Ako krenemo od medijane dobijamo istu vrednost kao za Njutnovu metodu. Medjutim, prednost Fišerove modifikacije je u tome što je manje osetljiva na odabir početne tačke. Na primer, Njutnova metoda je divergirala kad uzmemo prosek, ali Fišerova nalazi tačno rešenje: newton(mean(xs), dlogL, fishd2logL, x = xs, maxiter=100, trace=TRUE) ## [1] 14.34473 ## [1] 13.6144 ## [1] 12.79706 ## [1] 11.88649 ## [1] 10.89827 ## [1] 10.1139 ## [1] 9.940372 ## [1] 9.93974 ## [1] 9.939738 ## [1] 9.939738 ## [1] 9.939738 Fišerova metoda radi čak i ako krenemo od nule, koja je daleko od pravog rešenja. newton(0, dlogL, fishd2logL, x = xs, maxiter=100, trace=TRUE) ## [1] 0 ## [1] 0.3896712 ## [1] 0.7888266 ## [1] 1.201395 ## [1] 1.629696 ## [1] 2.073622 ## [1] 2.534672 ## [1] 3.017656 ## [1] 3.527813 ## [1] 4.069456 ## [1] 4.651676 ## [1] 5.283916 ## [1] 5.973198 ## [1] 6.735188 ## [1] 7.597059 ## [1] 8.568795 ## [1] 9.511005 ## [1] 9.91561 ## [1] 9.939628 ## [1] 9.939738 ## [1] 9.939738 ## [1] 9.939738 Možemo primetiti da imamo dosta više iteracija u Fišerovoj verziji, što je mana ove metode u odnosu na Njutnovu, koja brže konvergira (ukoliko konvergira). "],
["211-em.html", "4.2 EM algoritam", " 4.2 EM algoritam EM algoritam (Expectation-Maximization) je algoritam za nalaženje ocena maksimalne verodostojnosti, koji nalazi veoma široku upotrebu u statistici, posebno Bajesovskoj. Glavna ideja je da nam omogući da nadjemo ocene maksimalne verodostojnosti u prisustvu nedostajućih podataka ili skrivenih parametara. Ilustrovaćemo postupak kroz dva primera. 4.2.1 Ocena parametra sa histograma Pretpostavimo da smo, umesto konkretnog uzorka, dobili samo histogram odredjenog uzorka iz eksponencijalne raspodele sa nepoznatim parametrom \\(\\lambda\\) koji želimo da ocenimo na osnovu tog histograma. set.seed(1) # napravicemo histogram uzorka iz iz nepoznate eksponencijalne raspodele h &lt;- hist(rexp(1000, rate = rexp(1, 0.1))) h ## $breaks ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 ## ## $counts ## [1] 509 266 121 58 22 11 8 2 3 ## ## $density ## [1] 5.09 2.66 1.21 0.58 0.22 0.11 0.08 0.02 0.03 ## ## $mids ## [1] 0.05 0.15 0.25 0.35 0.45 0.55 0.65 0.75 0.85 ## ## $xname ## [1] &quot;rexp(1000, rate = rexp(1, 0.1))&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; Budući da je logaritamska verodostojnost jednaka \\[\\log L(\\lambda; \\mathbf{x})=n\\log\\lambda - \\lambda\\sum_{i=1}^nx_i,\\] klasičnim postupkom možemo zaključiti da je ocena maksimalne verodostojnosti \\[\\hat{\\lambda} = \\frac{n}{\\sum_{i=1}^nx_i}=\\frac1{\\overline{X}_n}.\\] Medjutim, naš problem je sada što mi nemamo uzorak \\(x_1,\\dots,x_n\\), pa ovako ne možemo odrediti ocenu. Ono što imamo je niz parova \\((u_1,v_1),\\dots,(u_n, v_n)\\) koji odredjuju kom intevalu pripadaju odgovarajući elementi uzorka. Dakle, \\(x_i\\in(u_i,v_i),\\ \\forall i=1,\\dots,n.\\) Srećom, na osnovu znanja o intervalu kom pripada \\(x_i\\) možemo oceniti vrednost elementa \\(x_i\\) uzimanjem uslovnog očekivanja, tačnije: \\[\\hat{x_i} = E\\left(X_i\\mid X_i\\in(u_i,v_i)\\right)=\\frac1\\lambda + \\frac{u_ie^{-\\lambda u_i} - v_ie^{-\\lambda v_i}}{e^{-\\lambda u_i} - e^{-\\lambda v_i}}.\\] Izvodjenje ovog uslovnog očekivanja ostavljamo čitaocu kao dobru vežbu za utvrdjivanje znanja iz Teorije verovatnoće. Ovde opet imamo problem, sada nam nije poznato \\(\\lambda\\), pa ne možemo da odredimo tačnu ocenu elemenata uzorka. Vidimo da imamo “cirkularnu” zavisnost izmedju \\(\\lambda\\) i \\(x_i\\), ako ne znamo jedno, ne možemo oceniti drugo. Zato ćemo pribeći iterativnom algortmu. Počećemo od neke proizvoljne ocene \\(\\hat{\\lambda}\\). (korak E) Iskoristićemo ovu ocenu da odredimo očekivanje \\[\\hat{x_i} = \\frac{1}{\\hat{\\lambda}} + \\frac{u_ie^{-\\hat{\\lambda} u_i} - v_ie^{-\\hat{\\lambda} v_i}}{e^{-\\hat{\\lambda} u_i} - e^{-\\hat{\\lambda} v_i}},\\ i=1,\\dots,n.\\] (korak M) Na osnovu ocena elemenata \\(x_i\\), poboljšaćemo ocenu \\(\\lambda\\) maksimizovanjem funkcije verodostojnosi, tj. uzimamo \\[\\hat{\\lambda} = \\underset{\\lambda}{\\mathrm{argmax}}\\log L(\\lambda; \\mathbf{\\hat{x}})=\\frac{n}{\\sum_{i=1}^n\\hat{x_i}}.\\] Ponavljamo korake E i M iterativno dok ne konvergiramo nekoj oceni nepoznatog parametra \\(\\lambda\\). Vidimo odakle potiče ime EM algoritma – smenjujemo korake E i M dok ne dobijemo dobru ocenu (ne maksimizujemo neko očekivanje). Primenimo konačno ovaj algoritam da dobijemo ocenu za naš uzorak. Prvo ćemo implementirati algoritam i potrebne korake. # korak E - ocekivanja x-eva na osnovu neke cene lambda expected_xs &lt;- function(lambda, u, v) { 1/lambda + (u*exp(-lambda*u) - v*exp(-lambda*v))/ (exp(-lambda*u) - exp(-lambda*v)) } # korak M - na osnovu ocenjenog uzorka, dati MMV ocenu lambda maximize_logL &lt;- function(xs) { 1/mean(xs) } # funkcija koja trazi ocenu EM algoritmom za datu pocetnu vrednost # lambda i vektor levih (u) i desnih (v) granica intervala za x_i EM_estimate &lt;- function(lambda_0, u, v, tol = 1e-8, maxiter = 1000) { xs &lt;- expected_xs(lambda_0, u, v) lambda &lt;- maximize_logL(xs) print(lambda) iter &lt;- 1 while((abs(lambda - lambda_0) &gt; tol) &amp;&amp; iter &lt; maxiter) { iter &lt;- iter + 1 lambda_0 &lt;- lambda xs &lt;- expected_xs(lambda_0, u, v) lambda &lt;- maximize_logL(xs) print(lambda) } lambda } Ostaje jos da odredimo na osnovu histograma vrednosti \\(u_i\\) i \\(v_i\\). Nije bitno uredjenje uzorka, pa možemo pretpostaviti da imamo sortiran uzorak \\(x_i\\). Odatle, ukoliko imamo 100 elemenata u prvom stupcu histograma, nekom intervalu \\((a,b)\\), onda možemo zaključiti da je \\(\\forall i=1,\\dots,100,\\ x_i\\in(u_i, v_i)=(a,b)\\), odnosno da je \\(u_1=\\dots=u_{100}=a\\) i \\(v_1=\\dots=v_{100}=b\\). Slično važi i za ostale stupce. U R-u niz parova \\((u_1,v_1),\\dots,(u_n, v_n)\\) možemo kreirati na sledeći način u &lt;- rep(head(h$breaks, -1), h$counts) v &lt;- rep(tail(h$breaks, -1), h$counts) Odavde sada možemo da odredimo ocenu \\(\\lambda\\) EM algoritmom: EM_estimate(1, u, v) ## [1] 7.129271 ## [1] 7.395976 ## [1] 7.407838 ## [1] 7.408366 ## [1] 7.408389 ## [1] 7.40839 ## [1] 7.40839 ## [1] 7.40839 ## [1] 7.40839 Zaključili smo da je ocena \\(\\hat{\\lambda} = 7.41\\). Pošto ne znamo da li je ova ocena tačna, na neki način treba proveriti kako se ova ocena uklapa u podatke. Najjednostavniji način je da preko histograma nacrtamo gustinu eksponencijalne raspodele sa ocenjenim parametrom. plot(h) # mnozenje sa 100 je da bismo sa gustine presli na skalu frekvencija # jer je density = counts / (sum(counts) * bin_width), sto je u nasem # slucaju density = counts / (1000 * 0.1) = counts / 100 curve(100*dexp(x, rate = 7.41), add=TRUE, col=&quot;steelblue&quot;, lwd = 2) Kriva vrlo dobro odgovara histogramu, pa možemo biti zadovljni ocenom. 4.2.2 Ocenjivanje mešavine normalnih raspodela Pretpostavimo da imamo uzorak \\(x_1,\\dots,x_n\\) iz mešavine dve normalne raspodele, sa gustinom \\[f(x) = (1-p)f_{\\mu_1}(x)+p f_{\\mu_2}(x),\\] gde su \\[f_{\\mu_i}(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu_i)^2}{2}},\\quad i=1,2.\\] Dakle imamo mešavinu normalnih \\(\\mathcal{N}(\\mu_1, 1)\\) i \\(\\mathcal{N}(\\mu_2, 1)\\) raspodela. Cilj će nam biti da odredimo, koristeći EM algoritam, ocene za parametre \\(\\mu_1\\) i \\(\\mu_2\\). Mešavina normalnih raspodela U našem primeru koristićemo vrednost \\(p = 0.7\\), radi jednostavnosti. Ovako izgleda odgovarajuća gustina dmix &lt;- function(x, mi1, mi2) { 0.3 * dnorm(x, mi1, 1) + 0.7 * dnorm(x, mi2, 1) } # Uzmemo konkretne vrednosti m_1 = -1 i m_2 = 3 curve(dmix(x, -1, 3), xlim = c(-10, 10)) Ova raspodela nastaje tako što \\(X\\) uzima vrednost iz jedne normalne raspodele sa verovatnoćom \\(p\\) ili iz druge normalne sa verovatnoćom \\(1-p\\). Dakle imamo dodatnu indikatorsku slučajnu veličinu \\[W\\sim\\mathcal{Ber}(p),\\] a slučajna veličina \\(X\\) je definisana kao \\[X = (1-W)Y_1+W\\,Y_2,\\] gde je \\(Y_i\\sim\\mathcal{N}(\\mu_i, 1),\\ i=1,2\\). Iz ovakve reprezentacije vidimo i način na koji možemo generisati odgovarajući uzorak. rmix &lt;- function(n) { u &lt;- runif(n) (u &lt; 0.3) * rnorm(n, -1) + (u &gt;= 0.3) * rnorm(n, 3) } Testiramo da li odgovara raspodeli… curve(dmix(x, -1, 3), xlim = c(-10, 10)) lines(density(rmix(100000)), col=&quot;green&quot;) Generišimo stoga uzorak na osnovu kog ćemo ilustrovati metodu. Stvarne vrednosti će biti \\(\\mu_1=-1\\) i \\(\\mu_2=3\\). uzorak &lt;- rmix(1000) Fun fact: Logaritam funkcije verodostojnosti se može nacrtati u 3 dimenzije koristeći paket rgl sledećim kodom. mixlogL &lt;- function(mi1, mi2) { sum(log(dmix(uzorak, mi1, mi2))) } mi1 &lt;- seq(-5,6,length.out = 100) mi2 &lt;- seq(-3,8,length.out = 100) z &lt;- outer(mi1, mi2, Vectorize(mixlogL)) library(rgl) persp3d(mi1, mi2, z, color = &quot;steelblue&quot;) Nalaženje ocene U ovom slučaju, kada imamo uzorak \\(x_1,\\dots,x_n\\) iz mešavine raspodela, skrivena promenljiva nam je pripadnost odredjenog elementa uzorka jednoj od raspodela, odnosno, iz vrednosti \\(X_i\\) ne znamo vrednost indikatora \\(w_i\\). Naravno, možemo oceniti vrednost tog indikatora uslovnim očekivanjem \\[\\hat{w_i}=E(W_i|X_i=x_i),\\] što nam čini korak E u EM algoritmu. Nakon kraćeg izvodjenja koje ostavljamo za vežbu iz Teorije verovatnoće dobijamo ocenu \\[\\hat{w_i}=P(W_i=1|X_i=x_i)=\\frac{pf_{\\mu_2}(x_i)}{(1-p)f_{\\mu_1}(x_i)+pf_{\\mu_2}(x_i)}.\\] Dakle korak E se implementira sledećom funkcijom # za p smo uzeli 0.7 expectation &lt;- function(mi1, mi2, xs) { 0.7*dnorm(xs, mi2) / (0.3*dnorm(xs, mi1) + 0.7*dnorm(xs, mi2)) } Ova funkcija zavisi od nepoznatih parametara \\(\\mu_1\\) i \\(\\mu_2\\), tako da nam je potreban način da njih ocenimo u M koraku EM algoritma. Pošto je uslovna gustina \\[f_{X|W=w_i}(x_i)=\\begin{cases}f_{\\mu_1}(x_i),&amp; w_i=0\\\\ f_{\\mu_2}(x_i),&amp; w_i=1\\end{cases},\\] logaritamska funkcija verodostojnosti, kada imamo znanje o skrivenoj promenljivoj \\(W\\) (a imačemo ocenu iz koraka E), će biti \\[\\begin{align} \\log L(\\mathbf{\\mu}; \\mathbf{x}, \\mathbf{w}) &amp;= \\log \\left(\\prod_{w_i=0}f_{\\mu_1}(x_i)\\prod_{w_i=1}f_{\\mu_2}(x_i)\\right)\\\\ &amp;= \\sum_{w_i=0}\\log f_{\\mu_1}(x_i) + \\sum_{w_i=1}\\log f_{\\mu_2}(x_i)\\\\ &amp;= \\sum_{i=1}^n ((1-w_i)\\log f_{\\mu_1}(x_i)+w_i\\log f_{\\mu_2}(x_i)), \\end{align}\\] gde je \\(\\mathbf{\\mu}=(\\mu_1,\\mu_2)^\\top\\). Odavde vidimo da je ocena metodom maksimalne verodostojnosti za \\(\\mu\\) jednaka \\[\\hat{\\mathbf{\\mu}} = \\underset{\\mu}{\\mathrm{argmax}}\\log L(\\mathbf{\\mu}; \\mathbf{x}, \\mathbf{w}).\\] Sad možemo da implementiramo korak M algoritma # logaritam verodostojnosti logLxw &lt;- function(mi1, mi2, xs, ws) { sum((1-ws)*log(dnorm(xs, mi1)) + ws*log(dnorm(xs, mi2))) } # trazimo argmax(L) tako sto nadjemo argmin(-L) pomocu funkcije nlm maximization &lt;- function(Ew, xs, mi_0) { nlm(function(mi) -logLxw(mi[1], mi[2], xs, Ew), mi_0)$estimate } Kada imamo sve korake implementirane, ostaje samo da implementiramo sam algoritam koji iterira ove korake EM_estimate_mix &lt;- function(mi_0, xs, tol=1e-6, maxiter=100) { iter &lt;- 0 Ew &lt;- expectation(mi_0[1], mi_0[2], xs) mi &lt;- maximization(Ew, xs, mi_0) print(mi) while(any(abs(mi - mi_0) &gt; tol)){ if(iter == maxiter) break mi_0 &lt;- mi Ew &lt;- expectation(mi_0[1], mi_0[2], xs) mi &lt;- maximization(Ew, xs, mi_0) print(mi) iter &lt;- iter + 1 } mi } Primenimo algoritam za početnu vrednost \\(\\mathbf{\\mu}=(0,1)^\\top\\). EM_estimate_mix(c(0,1), uzorak) ## Warning in nlm(function(mi) -logLxw(mi[1], mi[2], xs, Ew), mi_0): NA/Inf ## replaced by maximum positive value ## Warning in nlm(function(mi) -logLxw(mi[1], mi[2], xs, Ew), mi_0): NA/Inf ## replaced by maximum positive value ## [1] -0.8442056 2.5452301 ## Warning in nlm(function(mi) -logLxw(mi[1], mi[2], xs, Ew), mi_0): NA/Inf ## replaced by maximum positive value ## [1] -1.132248 2.965951 ## [1] -1.113066 2.990345 ## [1] -1.106408 2.993856 ## [1] -1.104836 2.994616 ## [1] -1.104475 2.994789 ## [1] -1.104392 2.994828 ## [1] -1.104373 2.994837 ## [1] -1.104368 2.994841 ## [1] -1.104367 2.994842 ## [1] -1.104367 2.994842 ## [1] -1.104367 2.994842 Vidimo da je algoritam konvergirao ka \\(\\hat{\\mathbf{\\mu}}=(-0.97, 2.96)^\\top\\) približno pravoj vrednosti \\(\\mathbf{\\mu}=(-1, 3)^\\top\\). "],
["31-lm.html", "5 Osnove linearnih modela 5.1 Regresija 5.2 Linearna regresija 5.3 Linearni modeli u R-u", " 5 Osnove linearnih modela 5.1 Regresija Cilj regresije je da nadje funkcionalnu vezu izmedju obeležja \\(Y\\), koje nazivamo zavisnom promenljivom i obeležja \\(X\\), koje nazivamo nezavisnom promenljivom ili prediktorom. Ova veza je oblika \\[Y = f(X) + \\varepsilon,\\] gde je \\(\\varepsilon\\) slučajna greška modela, koja je nezavisna od \\(X\\). Prava funkcija \\(f(x)\\) je nepoznata, pa je treba oceniti na osnovu uzorka \\((x_i, y_i),\\ i=1,\\dots,n\\). Za uzorak pretpostavljamo da važi \\[y_i = f(x_i) + \\varepsilon_i,\\] gde za \\(\\varepsilon_i\\) pretpostavljamo da su nezavisni i \\(\\varepsilon_i\\sim\\mathcal{N}(0,1)\\), a potrebna nam je ocena \\(\\hat{f}(x)\\). Prostor svih mogućih funkcija \\(f(x)\\) je prevelik i nije ga moguće istražiti u potpunosti, pa stoga uvek pretpostavljamo odredjen (obično parametarski) oblik funkcije \\(f(x)\\), čime smanjujemo prostor funkcija nad kojim tražimo \\(f(x)\\). 5.2 Linearna regresija U linearnoj regresiji, pretpostavljamo da je funkcija koju tražimo oblika \\(f(x)=\\beta_0+\\beta_1x,\\) odnosno imamo model \\[y_i=\\beta_0+\\beta_1x_i+\\varepsilon_i.\\] Sada nam se zadatak nalaženja funkcije \\(f(x)\\) sveo na odredjivanje parametara \\(\\beta_0\\) i \\(beta_1\\) koji najbolje opisuju podatke. To se može raditi na mnogo načina, što pokazuje sledeći primer, koji koristi različite metode za ocenu. 5.2.1 Šta znači najbolje? Koristićemo podatke cars (ugradjene u R) koji prikazuju brzinu vozila i dužina puta potrebnog da se zaustavi. Podaci su za automobile iz 20-ih godina 20. veka. Za ocenu najbolje prave, koristićemo funkcije lm (ugradjena u R) i funkciju rq iz paketa quantreg. # install.packages(&quot;quantreg&quot;) library(ggplot2) library(quantreg) ## Loading required package: SparseM ## ## Attaching package: &#39;SparseM&#39; ## The following object is masked from &#39;package:base&#39;: ## ## backsolve ggplot(cars, aes(x=speed, y=dist)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se = FALSE, color=&quot;blue&quot;) + geom_smooth(method=&quot;rq&quot;, se = FALSE, color=&quot;red&quot;) Koja od ove dve prave bolje modeluje podatke? Ovo pitanje je pogrešno. Treba definisati koji je kriterijum da je nešto bolje od nečeg drugog. Obe ove prave su dobijene tako da budu optimalne u nekom smislu. Plava je dobijena da bude optimalna u srednjekvadratnom smislu, dok je crvena dobijena kao optimalna u srednjeapsolutnom smislu. Oba metoda su dobra, koji ćemo da koristimo zavisi od prirode podataka koje imamo i cilja istraživanja. U nastavku ćemo rekreirati ove prave samostalno. 5.2.2 Nalaženje optimalne prave Najčešći pristup traženju optimalnih vrednosti parametara \\(\\beta_0\\) i \\(\\beta_1\\) je metod najmanjih kvadrata, čiji je cilj minimizovanje srednjekvadratne greške \\[\\frac1n \\sum_{i=1}^n(y_i-\\beta_0-\\beta_1x_i)^2,\\] tj. minimizujemo srednjekvadratno odstupanje stvarnih vrednosti \\(y_i\\) i ocenjenih vrednosti \\(\\hat{y}_i=\\hat{\\beta}_0+\\hat\\beta_1x_i\\). Dakle, ocenjeni parametri su \\[(\\hat{\\beta}_0,\\hat\\beta_1) = \\underset{\\beta_0,\\beta_1}{\\mathrm{argmin}}\\frac1n \\sum_{i=1}^n(y_i-\\beta_0-\\beta_1x_i)^2.\\] Ove parametre nalazi funkcija lm. U slučaju funkcije rq, parametri su \\((\\hat{\\beta}_0,\\hat\\beta_1) = \\underset{\\beta_0,\\beta_1}{\\mathrm{argmin}}\\frac1n \\sum_{i=1}^n|y_i-\\beta_0-\\beta_1x_i|.\\) Primenimo sada stečeno znanje optimizacije da nadjemo tražene ocene mse &lt;- function(beta) { with(cars, { mean((dist - beta[1] - beta[2]*speed)^2) }) } beta_hat &lt;- nlm(mse, c(0,0))$estimate ggplot(cars, aes(x=speed, y=dist)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se = FALSE, color=&quot;blue&quot;) + geom_abline(intercept = beta_hat[1], slope = beta_hat[2]) Vidimo da smo pogodili pravu. Uradite isto i za apsolutnu grešku i funkciju rq. 5.3 Linearni modeli u R-u Glavna funkcija za pravljenje i analiziranje linearnih modela u R-u je funkcija lm. Ona prima kao prvi argument formulu u obliku y ~ x1 + x2 + x3, gde je sa leve strane ~, ovde y, zavisna promenljiva, a sa desne prediktori, gde znak + označava da se prediktor treba uključiti. Specijalna oznaka za prediktore je . (npr. y ~ .) koja označava da se za prediktore uzmu sve kolone iz tabele, izuzimajući zavisnu promenljivu. Dakle, u suštini . znači “sve ostale promenljive iz podataka”. Drugi argument funkciji lm je data.frame koji sadrži podatke. Model koji smo posmatrali za skup podataka cars se dobija kao: model &lt;- lm(dist ~ speed, cars) model ## ## Call: ## lm(formula = dist ~ speed, data = cars) ## ## Coefficients: ## (Intercept) speed ## -17.579 3.932 Kada pozovemo geom_smooth(method = &quot;lm&quot;), ggplot u poozadini napravi model lm(y~x, data) i njega nacrta. Najčešće korišćena funkcija uz lm (koja pravi model), je funkcija summary koja prikazuje osnovne rezultate modelovanja summary(model) ## ## Call: ## lm(formula = dist ~ speed, data = cars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -29.069 -9.525 -2.272 9.215 43.201 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -17.5791 6.7584 -2.601 0.0123 * ## speed 3.9324 0.4155 9.464 1.49e-12 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 15.38 on 48 degrees of freedom ## Multiple R-squared: 0.6511, Adjusted R-squared: 0.6438 ## F-statistic: 89.57 on 1 and 48 DF, p-value: 1.49e-12 Najviše pažnje ćemo posvetiti tabeli sa naslovom “Coefficients”. Ona sadrži 4 kolone, gde se svaki red odnosi na odgovarajući prediktor (u ovom slučaju imamo slobodan član – \\(\\beta_0\\) i koeficijent uz prediktor speed – \\(\\beta_1\\)). Kolone su sledeće: Estimate: Ocenjena vrednost koeficijenta uz prediktor Std. Error: Standardna greška ocene koeficijenta (\\(se(\\hat\\beta_j)\\)) t value: Vrednost t statistike, koja se koristi za testiranje značajnosti koeficijenata Pr(&gt;|t|): p vrednost t testa značajnosti odgovarajućeg koeficijenta zvezdice pored p vrednosti označavaju sa kojim nivoom značajnosti bi dobili statistički značajan rezultat (3 zvezdice predstavljaju p vrednost koja je manja od 1 promila). Testiranje značajnosti koeficijenata U tabeli koeficijenata dobijamo neke rezultate testiranja značajnosti koeficijenata. Pri tom testiranju testiramo da li je koeficijent \\(\\beta_j\\) statistički značajan, odnosno, da li se može izbaciji iz modela, a da to ne utiče na kvalitet. Formalno, testiramo \\[H_0: \\beta_j=0\\quad H_1:\\beta_j\\neq0,\\] dok je test statistika koja se koristi \\[t = \\frac{\\hat\\beta_j}{se(\\hat\\beta_j)} \\sim t_{n-p-1},\\] gde je \\(p\\) broj prediktora (u slučaju proste regresije, sa 1 prediktorom, \\(p=1\\)). "]
]
